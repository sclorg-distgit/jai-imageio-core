diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/I18N.java zzx2/src/share/classes/com/sun/media/jai/imageioimpl/I18N.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/I18N.java	2005-02-11 00:01:54.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/I18N.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,53 +0,0 @@
-/*
- * $RCSfile: I18N.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:54 $
- * $State: Exp $
- */
-package com.sun.media.jai.imageioimpl;
-
-import com.sun.media.imageioimpl.common.I18NImpl;
-
-final class I18N extends I18NImpl {
-    static String getString(String key) {
-        return getString("com.sun.media.jai.imageioimpl.I18N", key);
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageIOCollectionImage.java zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageIOCollectionImage.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageIOCollectionImage.java	2005-02-11 00:01:54.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageIOCollectionImage.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,74 +0,0 @@
-/*
- * $RCSfile: ImageIOCollectionImage.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:54 $
- * $State: Exp $
- */
-package com.sun.media.jai.imageioimpl;
-
-import java.util.ArrayList;
-import javax.media.jai.CollectionImage;
-
-/**
- * A <code>CollectionImage</code> to be used as the return value from
- * <code>ImageReadCIF.create()</code> and <code>ImageWriteCIF.create()</code>.
- * The <code>imageCollection</code> instance variable is a <code>List</code>.
- */
-class ImageIOCollectionImage extends CollectionImage {
-    /**
-     * Creates an <code>ImageIOCollectionImage</code> with the specified
-     * capacity.
-     *
-     * @exception IllegalArgumentException if <code>capacity</code> is
-     * not positive.
-     */
-    ImageIOCollectionImage(int capacity) {
-        super();
-
-        if(capacity <= 0) {
-            // No message as this is not at the API level and it is
-            // the unique exception.
-            throw new IllegalArgumentException();
-        }
-
-        imageCollection = new ArrayList(capacity);
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadCIF.java zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadCIF.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadCIF.java	2005-02-11 00:01:54.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadCIF.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,168 +0,0 @@
-/*
- * $RCSfile: ImageReadCIF.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:54 $
- * $State: Exp $
- */
-package com.sun.media.jai.imageioimpl;
-
-import java.awt.Dimension;
-import java.awt.RenderingHints;
-import java.awt.image.renderable.ParameterBlock;
-import java.util.ArrayList;
-import java.util.List;
-import javax.imageio.ImageReader;
-import javax.media.jai.CollectionImage;
-import javax.media.jai.CollectionImageFactory;
-import javax.media.jai.CollectionOp;
-import javax.media.jai.JAI;
-import javax.media.jai.PlanarImage;
-import com.sun.media.jai.operator.ImageReadDescriptor;
-
-public class ImageReadCIF implements CollectionImageFactory {
-
-    static CollectionImage createStatic(ParameterBlock args,
-                                        RenderingHints hints) {
-
-        // Clone the ParameterBlock as the ImageChoice will be overwritten.
-        ParameterBlock renderedPB = (ParameterBlock)args.clone();
-
-        // Get the ImageChoice.
-        int[] imageIndices = (int[])args.getObjectParameter(1);
-
-        // Variables to be set in the subsequent "if" block.
-        // XXX Could probably collapse the if block into a single code seq.
-        int numSources;
-        ImageIOCollectionImage imageList = null;
-
-        if(imageIndices == null) {
-            // null-valued ImageChoice: load all images.
-
-            // Load the first image.
-            renderedPB.set(0, 1);
-            PlanarImage image = JAI.create("ImageRead", renderedPB, hints);
-
-            // Get the ImageReader property.
-            Object readerProperty =
-                image.getProperty(
-                    ImageReadDescriptor.PROPERTY_NAME_IMAGE_READER);
-
-            // Try to read the number of images.
-            if(readerProperty instanceof ImageReader) {
-                try {
-                    // XXX Really should not allow search here. If search
-                    // is disallowed and -1 is returned from getNumImages(),
-                    // then "ImageRead" should just be called until an
-                    // IndexOutOfBoundsException is caught.
-                    numSources =
-                        ((ImageReader)readerProperty).getNumImages(true);
-                } catch(Exception e) { // IOException
-                    // Default to one source.
-                    numSources = 1;
-                }
-            } else {
-                numSources = 1;
-            }
-
-            // Allocate and fill index array.
-            imageIndices = new int[numSources];
-            for(int i = 0; i < numSources; i++) {
-                imageIndices[i] = i;
-            }
-
-            // Allocate list and add first image.
-            imageList = new ImageIOCollectionImage(numSources);
-            imageList.add(image);
-        } else {
-            // Set the number of sources and create the list.
-            numSources = imageIndices.length;
-            imageList = new ImageIOCollectionImage(numSources);
-
-            // Load the first image requested.
-            renderedPB.set(imageIndices[0], 1);
-            PlanarImage image = JAI.create("ImageRead", renderedPB, hints);
-
-            // Add the first image to the list.
-            imageList.add(image);
-        }
-
-        // Read subsequent images and add to the list.
-        for(int idx = 1; idx < numSources; idx++) {
-            renderedPB.set(imageIndices[idx], 1);
-            PlanarImage image = JAI.create("ImageRead", renderedPB, hints);
-            imageList.add(image);
-        }
-
-        // Get the first image in the Collection.
-        PlanarImage firstImage = (PlanarImage)imageList.get(0);
-
-        // Transfer properties to the Collection.
-        ImageReadCRIF.copyProperty(firstImage,
-                                   imageList,
-                                   ImageReadDescriptor.PROPERTY_NAME_IMAGE_READ_PARAM);
-        ImageReadCRIF.copyProperty(firstImage,
-                                   imageList,
-                                   ImageReadDescriptor.PROPERTY_NAME_IMAGE_READER);
-        ImageReadCRIF.copyProperty(firstImage,
-                                   imageList,
-                                   ImageReadDescriptor.PROPERTY_NAME_METADATA_STREAM);
-
-        return imageList;
-    }
-
-    /** Constructor. */
-    public ImageReadCIF() {}
-
-    public CollectionImage create(ParameterBlock args,
-                                  RenderingHints hints) {
-        return createStatic(args, hints);
-    }
-
-    // Forget it.
-    public CollectionImage update(ParameterBlock oldParamBlock,
-                                  RenderingHints oldHints,
-                                  ParameterBlock newParamBlock,
-                                  RenderingHints newHints,
-                                  CollectionImage oldRendering,
-                                  CollectionOp op) {
-        return null;
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadCRIF.java zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadCRIF.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadCRIF.java	2005-11-30 19:39:04.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadCRIF.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,434 +0,0 @@
-/*
- * $RCSfile: ImageReadCRIF.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.2 $
- * $Date: 2005/12/01 00:39:04 $
- * $State: Exp $
- */
-package com.sun.media.jai.imageioimpl;
-
-import java.awt.Dimension;
-import java.awt.RenderingHints;
-import java.awt.geom.Rectangle2D;
-import java.awt.image.RenderedImage;
-import java.awt.image.renderable.ParameterBlock;
-import java.awt.image.renderable.RenderableImage;
-import java.awt.image.renderable.RenderContext;
-import java.io.FileInputStream;
-import java.io.InputStream;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.net.Socket;
-import java.net.URL;
-import java.nio.channels.Channel;
-import java.nio.channels.Channels;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.EventListener;
-import java.util.Iterator;
-import java.util.Locale;
-import java.util.TreeMap;
-import java.util.Vector;
-import javax.imageio.ImageIO;
-import javax.imageio.ImageReader;
-import javax.imageio.ImageReadParam;
-import javax.imageio.event.IIOReadProgressListener;
-import javax.imageio.event.IIOReadUpdateListener;
-import javax.imageio.event.IIOReadWarningListener;
-import javax.imageio.spi.ImageReaderSpi;
-import javax.imageio.stream.ImageInputStream;
-import javax.media.jai.CRIFImpl;
-import javax.media.jai.ImageLayout;
-import javax.media.jai.JAI;
-import javax.media.jai.MultiResolutionRenderableImage;
-import javax.media.jai.PropertySource;
-import javax.media.jai.WritablePropertySource;
-import com.sun.media.jai.operator.ImageReadDescriptor;
-
-public final class ImageReadCRIF extends CRIFImpl {
-    public ImageReadCRIF() {
-        super(); // Pass up the name?
-    }
-
-    /**
-     * Attempt to create an {@link ImageInputStream} for the supplied
-     * input. The following sequence is effected:
-     * <ol>
-     * <li><ul>
-     * <li>If <code>input</code> is an <code>ImageInputStream</code> it
-     * is cast and returned.</li>
-     * <li>If <code>input</code> is a <code>String</code> it is converted
-     * to a read-only <code>RandomAccessFile</code>.</li>
-     * <li>If conversion to a <code>RandomAccessFile</code> fails, the 
-     * <code>String</code> <code>input</code> is converted to an 
-     * <code>InputStream</code> by accessing it as a resource bundled 
-     * in a JAR file.</li>
-     * <li>If <code>input</code> is a <code>URL</code> it is converted
-     * to an <code>InputStream</code>.</li>
-     * <li>If <code>input</code> is a <code>Socket</code> it is converted
-     * to an <code>InputStream</code>.</li>
-     * </ul></li>
-     * <li><code>ImageIO.createImageInputStream()</code> is invoked
-     * with parameter set to the (possibly converted) input and the
-     * value it returns (which could be <code>null</code>) is returned
-     * to the caller.</li>
-     * </ol>
-     *
-     * @param input An <code>Object</code> to be used as the source,
-     * such as a <code>String</code>, <code>URL</code>, <code>File</code>,
-     * readable <code>RandomAccessFile</code>, <code>InputStream</code>,
-     * readable <code>Socket</code>, or readable <code>Channel</code>.
-     * 
-     * @return An <code>ImageInputStream</code> or <code>null</code>.
-     */
-    private static ImageInputStream getImageInputStream(Object input) {
-        // The value to be returned.
-        ImageInputStream stream = null;
-
-        // If already an ImageInputStream cast and return.
-        if(input instanceof ImageInputStream) {
-            stream = (ImageInputStream)input;
-        } else {
-            // If the input is a String replace it with a RandomAccessFile.
-            if(input instanceof String) {
-                try {
-                    // 'input' is conditionally checked for readability
-                    // in the OperationDescriptor.
-                    input = new RandomAccessFile((String)input, "r");
-                } catch(Exception e) {
-		    // Try to get the file as an InputStream resource. This 
-		    // would happen when the application and image file are 
-		    // packaged in a JAR file
-		    input = ImageReadCRIF.class.getClassLoader().getResourceAsStream((String)input);
-		    if (input == null) 
-			throw new RuntimeException
-			    (I18N.getString("ImageReadCRIF0")+" "+input);
-                }
-            } else if(input instanceof URL) {
-                // If the input is a URL replace it with an InputStream.
-                try {
-                    input = ((URL)input).openStream();
-                } catch(Exception e) {
-                    throw new RuntimeException
-                        (I18N.getString("ImageReadCRIF1")+" "+input);
-                }
-            } else if(input instanceof Socket) {
-                // If output is a Socket replace it with an InputStream.
-                try {
-                    Socket socket = (Socket)input;
-                    // XXX check binding, connection, closed, shutdown
-                    // as these could have changed.
-                    input = socket.getInputStream();
-                } catch(Exception e) {
-                    throw new RuntimeException
-                        (I18N.getString("ImageReadCRIF2")+" "+input);
-                }
-            }
-        }
-
-        // Create the ImageInputStream.
-        try {
-            stream = ImageIO.createImageInputStream(input);
-        } catch(Exception e) {
-            throw new RuntimeException(e);
-        }
-
-        return stream;
-    }
-
-    /**
-     * Get the <code>ImageReader</code> and set its input and metadata flag.
-     * The input set on the reader might not be the same object as the input
-     * passed in if the latter was replaced by getImageInputStream().
-     */
-    static ImageReader getImageReader(ParameterBlock pb) {
-        // Get the input.
-        Object input = pb.getObjectParameter(0);
-
-        // Get the reader parameter.
-        ImageReader reader = (ImageReader)pb.getObjectParameter(8);
-
-        // Attempt to create an ImageInputStream from the input.
-        ImageInputStream stream = getImageInputStream(input);
-
-        // If no reader passed in, try to find one.
-        if(reader == null) {
-            // Get all compatible readers.
-            Iterator readers = ImageIO.getImageReaders(stream != null ?
-                                                       stream : input);
-
-            // If any readers, take the first one whose originating
-            // service provider indicates that it can decode the input.
-            if(readers != null && readers.hasNext()) {
-                do {
-                    ImageReader tmpReader = (ImageReader)readers.next();
-                    ImageReaderSpi readerSpi =
-                        tmpReader.getOriginatingProvider();
-                    try {
-                        if(readerSpi.canDecodeInput(stream != null ?
-                                                    stream : input)) {
-                            reader = tmpReader;
-                        }
-                    } catch(IOException ioe) {
-                        // XXX Ignore it?
-                    }
-                } while(reader == null && readers.hasNext());
-            }
-        }
-
-        // If reader found, set its input and metadata flag.
-        if(reader != null) {
-            // Get the locale parameter and set on the reader.
-            Locale locale = (Locale)pb.getObjectParameter(6);
-            if(locale != null) {
-                reader.setLocale(locale);
-            }
-
-            // Get the listeners parameter and set on the reader.
-            EventListener[] listeners =
-                (EventListener[])pb.getObjectParameter(5);
-            if(listeners != null) {
-                for(int i = 0; i < listeners.length; i++) {
-                    EventListener listener = listeners[i];
-                    if(listener instanceof IIOReadProgressListener) {
-                        reader.addIIOReadProgressListener(
-                            (IIOReadProgressListener)listener);
-                    }
-                    if(listener instanceof IIOReadUpdateListener) {
-                        reader.addIIOReadUpdateListener(
-                            (IIOReadUpdateListener)listener);
-                    }
-                    if(listener instanceof IIOReadWarningListener) {
-                        reader.addIIOReadWarningListener(
-                            (IIOReadWarningListener)listener);
-                    }
-                }
-            }
-
-            // Get the metadata reading flag.
-            boolean readMetadata =
-                ((Boolean)pb.getObjectParameter(2)).booleanValue();
-
-            // Set the input and indicate metadata reading state.
-            reader.setInput(stream != null ? stream : input,
-                            false,          // seekForwardOnly
-                            !readMetadata); // ignoreMetadata
-        }
-
-        return reader;
-    }
-
-    static void copyProperty(PropertySource ps,
-                             WritablePropertySource wps,
-                             String propertyName) {
-        Object propertyValue = ps.getProperty(propertyName);
-
-        if(propertyValue != null &&
-           !propertyValue.equals(java.awt.Image.UndefinedProperty)) {
-            wps.setProperty(propertyName, propertyValue);
-                                        
-        }
-    }
-
-    public RenderedImage create(ParameterBlock pb,
-                                RenderingHints rh) {
-
-        // Value to be returned.
-        RenderedImage image = null;
-
-        // Get the reader.
-        ImageReader reader = getImageReader(pb);
-
-        // Proceed if a compatible reader was found.
-        if(reader != null) {
-            // Get the remaining parameters required.
-            int imageIndex = pb.getIntParameter(1);
-            ImageReadParam param =
-                (ImageReadParam)pb.getObjectParameter(7);
-            boolean readThumbnails =
-                ((Boolean)pb.getObjectParameter(3)).booleanValue();
-
-            // Initialize the layout.
-            ImageLayout layout =
-                (rh != null && rh.containsKey(JAI.KEY_IMAGE_LAYOUT)) ?
-                (ImageLayout)rh.get(JAI.KEY_IMAGE_LAYOUT) :
-                new ImageLayout();
-
-            try {
-                // Get the parameter input.
-                Object paramInput = pb.getObjectParameter(0);
-
-                // Get the reader input.
-                Object readerInput = reader.getInput();
-
-                // Set the stream to close when the OpImage is disposed.
-                ImageInputStream streamToClose = null;
-                if(readerInput != paramInput &&
-                   readerInput instanceof ImageInputStream) {
-                    streamToClose = (ImageInputStream)readerInput;
-                }
-
-                // Create the rendering.
-                image = new ImageReadOpImage(layout,
-                                             rh,
-                                             param,
-                                             reader,
-                                             imageIndex,
-                                             readThumbnails,
-                                             streamToClose);
-            } catch(Exception e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        return image;
-    }
-
-    // XXX This implementation of renderable mode is incredibly lame
-    // but the architecture and implementation allow for nothing else.
-    // It would be better if the CRIFs had some kind of state that
-    // could be associated with them. As it standards getBounds2D()
-    // will create a new MultiResolutionRenderableImage and so will
-    // the second create() below. Actually what is needed is a
-    // RenderableImageFactory definition.
-    // XXX There is also a problem with multiple invocations of the
-    // rendered mode case. Without saving and seeking back to the
-    // same offset it appears to have problems. Should ImageReadOpImage
-    // save the initial position and always seek back to it?
-
-    public RenderableImage createRenderable(ParameterBlock pb,
-                                            RenderingHints rh) {
-
-        // Read the collection.
-        Collection sequence = ImageReadCIF.createStatic(pb, rh);
-
-        // Create a SortedMap which sorts on the basis of inverse area.
-        // The keys will be Dimensions and the objects RenderedImages.
-        TreeMap sourceMap = new TreeMap(new Comparator() {
-                public int compare(Object o1, Object o2) {
-                    Dimension d1 = (Dimension)o1;
-                    Dimension d2 = (Dimension)o2;
-
-                    int area1 = d1.width*d1.height;
-                    int area2 = d2.width*d2.height;
-
-                    double inverse1 = area1 == 0 ?
-                        Double.MAX_VALUE : 1.0/area1;
-                    double inverse2 = area2 == 0 ?
-                        Double.MAX_VALUE : 1.0/area2;
-
-                    if(inverse1 < inverse2) {
-                        return -1;
-                    } else if(inverse1 > inverse2) {
-                        return 1;
-                    } else {
-                        return 0;
-                    }
-                }
-
-                public boolean equals(Object o1, Object o2) {
-                    return o1.equals(o2);
-                }
-            });
-
-        Iterator images = sequence.iterator();
-        while(images.hasNext()) {
-            RenderedImage image = (RenderedImage)images.next();
-            sourceMap.put(new Dimension(image.getWidth(), image.getHeight()),
-                          image);
-        }
-
-        // Create the rendered source list sorted by inverse area.
-        Vector renderedSources = new Vector(sourceMap.size());
-        Iterator keys = sourceMap.keySet().iterator();
-        while(keys.hasNext()) {
-            renderedSources.add(sourceMap.get(keys.next()));
-        }
-
-        // Create the RenderableImage from the sorted RenderedImages.
-        MultiResolutionRenderableImage renderableImage =
-            new MultiResolutionRenderableImage(renderedSources,
-                                               0.0F, 0.0F, 1.0F);
-
-        // Set properties from those of the first rendered source.
-        PropertySource firstSource = (PropertySource)renderedSources.get(0);
-        copyProperty(firstSource,
-                     renderableImage,
-                     ImageReadDescriptor.PROPERTY_NAME_IMAGE_READ_PARAM);
-        copyProperty(firstSource,
-                     renderableImage,
-                     ImageReadDescriptor.PROPERTY_NAME_IMAGE_READER);
-        copyProperty(firstSource,
-                     renderableImage,
-                     ImageReadDescriptor.PROPERTY_NAME_METADATA_STREAM);
-        copyProperty(firstSource,
-                     renderableImage,
-                     ImageReadDescriptor.PROPERTY_NAME_METADATA_IMAGE);
-
-        // Return the RenderableImage.
-        return renderableImage;
-    }
-
-    public RenderedImage create(RenderContext rc,
-                                ParameterBlock pb) {
-
-        RenderableImage renderableImage =
-            createRenderable(pb, rc.getRenderingHints());
-
-        RenderedImage renderedImage = renderableImage.createRendering(rc);
-
-        ((WritablePropertySource)renderedImage).setProperty(
-            ImageReadDescriptor.PROPERTY_NAME_RENDERABLE_INPUT,
-            (PropertySource)renderableImage);
-
-        return renderedImage;
-    }
-
-    public Rectangle2D getBounds2D(ParameterBlock pb) {
-        // XXX Should just get the aspect ratio of the first image and use it.
-        // Otherwise this will be very inefficient.
-        RenderableImage renderable = createRenderable(pb, null);
-
-        return new Rectangle2D.Float(renderable.getMinX(),
-                                     renderable.getMinY(),
-                                     renderable.getWidth(),
-                                     renderable.getHeight());
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadOpImage.java zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadOpImage.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadOpImage.java	2006-07-14 17:43:57.000000000 -0400
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadOpImage.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,914 +0,0 @@
-/*
- * $RCSfile: ImageReadOpImage.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.2 $
- * $Date: 2006/07/14 21:43:57 $
- * $State: Exp $
- */
-package com.sun.media.jai.imageioimpl;
-
-import java.awt.Dimension;
-import java.awt.Point;
-import java.awt.Rectangle;
-import java.awt.image.BufferedImage;
-import java.awt.image.ColorModel;
-import java.awt.image.Raster;
-import java.awt.image.SampleModel;
-import java.awt.image.WritableRaster;
-import java.io.InputStream;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Map;
-import javax.imageio.ImageReader;
-import javax.imageio.ImageReadParam;
-import javax.imageio.ImageTypeSpecifier;
-import javax.imageio.metadata.IIOMetadata;
-import javax.imageio.spi.ImageReaderSpi;
-import javax.imageio.stream.ImageInputStream;
-import javax.media.jai.ImageLayout;
-import javax.media.jai.OpImage;
-import com.sun.media.jai.operator.ImageReadDescriptor;
-
-/**
- * Implementation of the <code>OpImage</code> of the "ImageRead" operation.
- */
-final class ImageReadOpImage extends OpImage {
-
-    /**
-     * XXX For testing only.
-     */
-    /* XXX
-    public static void main(String[] args) throws Throwable {
-        java.io.File file = new java.io.File(args[0]);
-        int imageIndex = args.length > 1 ?
-            Integer.valueOf(args[1]).intValue() : 0;
-        int tileSize = args.length > 2 ?
-            Integer.valueOf(args[2]).intValue() : 128;
-
-        javax.imageio.stream.ImageInputStream stream =
-            new javax.imageio.stream.FileImageInputStream(file);
-
-        Iterator iter = javax.imageio.ImageIO.getImageReaders(stream);
-        ImageReader imageReader = (ImageReader)iter.next();
-        imageReader.setInput(stream,
-                             true, // seekForwardOnly
-                             false); // ignoreMetadata
-
-        ImageLayout layout = new ImageLayout();
-        layout.setTileWidth(tileSize).setTileHeight(tileSize);
-        //layout.setTileGridXOffset(42).setTileGridYOffset(7);
-
-        ImageReadParam param = imageReader.getDefaultReadParam();
-        param.setSourceSubsampling(2, 2, 0, 0);
-        param.setSourceRegion(new Rectangle(128, 0, 256, 256));
-        param.setSourceBands(new int[] {2, 1, 0});
-        param.setDestinationBands(new int[] {0, 1, 2});
-
-        OpImage image = new ImageReadOpImage(layout, // ImageLayout
-                                             null, // Map
-                                             param, // ImageReadParam
-                                             imageReader,
-                                             imageIndex,
-                                             true,
-                                             null); // streamToClose
-
-        System.out.println(new ImageLayout(image));
-
-        System.out.println("\nImage Properties:");
-        String[] propNames = image.getPropertyNames();
-        if(propNames != null) {
-            for(int i = 0; i < propNames.length; i++) {
-                System.out.println(i+" "+propNames[i]+" = "+
-                                   image.getProperty(propNames[i]));
-            }
-        }
-        System.out.println("");
-
-        BufferedImage[] thumbnails = null;
-        Object thumbnailProp =
-            image.getProperty(ImageReadDescriptor.PROPERTY_NAME_THUMBNAILS);
-        if(thumbnailProp != java.awt.Image.UndefinedProperty) {
-            thumbnails = (BufferedImage[])thumbnailProp;
-        }
-
-        java.awt.Frame frame =
-            new java.awt.Frame("ImageReadOpImage Test: "+file);
-        if(thumbnails != null) {
-            frame.setLayout(new java.awt.GridLayout(1, thumbnails.length+1));
-        }
-
-        frame.add(new javax.media.jai.widget.ScrollingImagePanel(image,
-                                                                 image.getWidth(),
-                                                                 image.getHeight()));
-        if(thumbnails != null) {
-            for(int i= 0; i < thumbnails.length; i++) {
-                frame.add(new javax.media.jai.widget.ScrollingImagePanel(thumbnails[i],
-                                                                         thumbnails[i].getWidth(),
-                                                                         thumbnails[i].getHeight()));
-            }
-        }
-        frame.pack();
-        frame.show();
-    }
-    */
-
-    /**
-     * The <code>ImageReadParam</code> used in reading the image.
-     */
-    private ImageReadParam param;
-
-    /**
-     * The <code>ImageReader</code> used to read the image.
-     */
-    private ImageReader reader;
-
-    /**
-     * The index of the image to be read.
-     */
-    private int imageIndex;
-
-    /**
-     * Whether thumbnails are to be read.
-     */
-    private boolean readThumbnails;
-
-    /**
-     * Whether stream metadata have been be read.
-     */
-    private boolean streamMetadataRead = false;
-
-    /**
-     * Whether image metadata have been be read.
-     */
-    private boolean imageMetadataRead = false;
-
-    /**
-     * A stream to be closed when the instance is disposed; may be null.
-     */
-    private ImageInputStream streamToClose;
-
-    /**
-     * Destination to source X scale factor.
-     */
-    private int scaleX;
-
-    /**
-     * Destination to source Y scale factor.
-     */
-    private int scaleY;
-
-    /**
-     * Destination to source X translation factor.
-     */
-    private int transX;
-
-    /**
-     * Destination to source Y translation factor.
-     */
-    private int transY;
-
-    /**
-     * Derive the image layout based on the user-supplied layout,
-     * reading parameters, and image index.
-     */
-    private static ImageLayout layoutHelper(ImageLayout il,
-                                            ImageReadParam param,
-                                            ImageReader reader,
-                                            int imageIndex)
-        throws IOException {
-        ImageLayout layout = (il == null) ?
-            new ImageLayout() : (ImageLayout)il.clone();
-
-        // --- Determine the image type. ---
-
-        // If not provided in the original layout, set the SampleModel
-        // and ColorModel from the ImageReadParam, if supplied.
-        if(!layout.isValid(ImageLayout.SAMPLE_MODEL_MASK) &&
-           !layout.isValid(ImageLayout.COLOR_MODEL_MASK)) {
-            // If an ImageReadParam has been supplied and has its
-            // destinationType set then use it. Otherwise default to
-            // the raw image type.
-            ImageTypeSpecifier imageType =
-                (param != null && param.getDestinationType() != null) ?
-                param.getDestinationType() :
-                reader.getRawImageType(imageIndex);
-
-            // XXX The following block of code should not be necessary
-            // but for J2SE 1.4.0 FCS ImageReader.getRawImageType(0)
-            // returns null for earth.jpg, Bas-noir.jpg, etc.
-            if(imageType == null) {
-                Iterator imageTypes = reader.getImageTypes(imageIndex);
-                while(imageType == null && imageTypes.hasNext()) {
-                    imageType = (ImageTypeSpecifier)imageTypes.next();
-                }
-            }
-
-            // XXX Should an exception be thrown if imageType is null?
-            if(imageType != null) {
-                // Set the SampleModel and ColorModel.
-                layout.setSampleModel(imageType.getSampleModel());
-                layout.setColorModel(imageType.getColorModel());
-            }
-        }
-
-        // --- Set up the destination bounds. ---
-
-        // Calculate the computable destination bounds.
-        Dimension sourceSize = getSourceSize(param, reader, imageIndex);
-        Rectangle srcRegion = new Rectangle();
-        Rectangle destRegion = new Rectangle();
-        computeRegions(param,
-                       sourceSize.width,
-                       sourceSize.height,
-                       layout.getMinX(null), // valid value or 0
-                       layout.getMinY(null), // valid value or 0
-                       false,
-                       srcRegion,
-                       destRegion);
-
-        if(!destRegion.isEmpty()) {
-           // Backup layout image bounds with computable bounds.
-           if(!layout.isValid(ImageLayout.WIDTH_MASK)) {
-               layout.setWidth(destRegion.width);
-           }
-           if(!layout.isValid(ImageLayout.HEIGHT_MASK)) {
-               layout.setHeight(destRegion.height);
-           }
-           if(!layout.isValid(ImageLayout.MIN_X_MASK)) {
-               layout.setMinX(destRegion.x);
-           }
-           if(!layout.isValid(ImageLayout.MIN_Y_MASK)) {
-               layout.setMinY(destRegion.y);
-           }
-
-           // Ensure the layout bounds intersect computable bounds.
-           Rectangle destBounds = new Rectangle(layout.getMinX(null),
-                                                layout.getMinY(null),
-                                                layout.getWidth(null),
-                                                layout.getHeight(null));
-           if(destRegion.intersection(destBounds).isEmpty()) {
-               throw new IllegalArgumentException
-                   (I18N.getString("ImageReadOpImage0"));
-           }
-        }
-
-        // --- Set up the tile grid. ---
-
-        if(!layout.isValid(ImageLayout.TILE_GRID_X_OFFSET_MASK)) {
-            layout.setTileGridXOffset(reader.getTileGridXOffset(imageIndex));
-        }
-        if(!layout.isValid(ImageLayout.TILE_GRID_Y_OFFSET_MASK)) {
-            layout.setTileGridYOffset(reader.getTileGridYOffset(imageIndex));
-        }
-        if(!layout.isValid(ImageLayout.TILE_WIDTH_MASK)) {
-            layout.setTileWidth(reader.getTileWidth(imageIndex));
-        }
-        if(!layout.isValid(ImageLayout.TILE_HEIGHT_MASK)) {
-            layout.setTileHeight(reader.getTileHeight(imageIndex));
-        }
-
-        return layout;
-    }
-
-    /**
-     * Returns whether an <code>ImageTypeSpecifier</code> may be used
-     * to read in the image at a specified index.
-     *
-     * XXX
-     */
-    private static boolean isCompatibleType(ImageTypeSpecifier imageType,
-                                            ImageReader reader,
-                                            int imageIndex)
-        throws IOException {
-        Iterator imageTypes = reader.getImageTypes(imageIndex);
-
-        boolean foundIt = false;
-        while (imageTypes.hasNext()) {
-            ImageTypeSpecifier type =
-                (ImageTypeSpecifier)imageTypes.next();
-            if (type.equals(imageType)) {
-                foundIt = true;
-                break;
-            }
-        }
-
-        return foundIt;
-    }
-
-    /**
-     * Returns the source region to be read. If the sourceRenderSize
-     * is being used it is returned; otherwise the raw source dimensions
-     * are returned.
-     *
-     * XXX
-     */
-    private static Dimension getSourceSize(ImageReadParam param,
-                                           ImageReader reader,
-                                           int imageIndex)
-        throws IOException {
-        Dimension sourceSize = null;
-        if(param != null && param.canSetSourceRenderSize()) {
-            sourceSize = param.getSourceRenderSize();
-        }
-        if(sourceSize == null) {
-            sourceSize = new Dimension(reader.getWidth(imageIndex),
-                                       reader.getHeight(imageIndex));
-        }
-        return sourceSize;
-    }
-
-    /**
-     * XXX
-     */
-    // Code copied from ImageReader.java
-    private static Rectangle getSourceRegion(ImageReadParam param,
-                                             int srcWidth,
-                                             int srcHeight) {
-        Rectangle sourceRegion = new Rectangle(0, 0, srcWidth, srcHeight);
-        if (param != null) {
-            Rectangle region = param.getSourceRegion();
-            if (region != null) {
-                sourceRegion = sourceRegion.intersection(region);
-            }
-
-            int subsampleXOffset = param.getSubsamplingXOffset();
-            int subsampleYOffset = param.getSubsamplingYOffset();
-            sourceRegion.x += subsampleXOffset;
-            sourceRegion.y += subsampleYOffset;
-            sourceRegion.width -= subsampleXOffset;
-            sourceRegion.height -= subsampleYOffset;
-        }
-
-        return sourceRegion;
-    }
-
-    /**
-     * XXX
-     */
-    // clipDestRegion: whether to clip destRegion to positive coordinates.
-    // Code based on method of same name in ImageReader.java
-    private static void computeRegions(ImageReadParam param,
-                                       int srcWidth,
-                                       int srcHeight,
-                                       int destMinX,
-                                       int destMinY,
-                                       boolean clipDestRegion,
-                                       Rectangle srcRegion,
-                                       Rectangle destRegion) {
-        if (srcRegion == null) {
-            throw new IllegalArgumentException("srcRegion == null");
-        }
-        if (destRegion == null) {
-            throw new IllegalArgumentException("destRegion == null");
-        }
-
-        // Start with the entire source image
-        srcRegion.setBounds(0, 0, srcWidth, srcHeight);
-
-        // Destination also starts with source image, as that is the
-        // maximum extent if there is no subsampling
-        destRegion.setBounds(destMinX, destMinY, srcWidth, srcHeight);
-
-        // Clip that to the param region, if there is one
-        int periodX = 1;
-        int periodY = 1;
-        int gridX = 0;
-        int gridY = 0;
-        if (param != null) {
-            Rectangle paramSrcRegion = param.getSourceRegion();
-            if (paramSrcRegion != null) {
-                srcRegion.setBounds(srcRegion.intersection(paramSrcRegion));
-            }
-            periodX = param.getSourceXSubsampling();
-            periodY = param.getSourceYSubsampling();
-            gridX = param.getSubsamplingXOffset();
-            gridY = param.getSubsamplingYOffset();
-            srcRegion.translate(gridX, gridY);
-            srcRegion.width -= gridX;
-            srcRegion.height -= gridY;
-            Point destinationOffset = param.getDestinationOffset();
-            destRegion.translate(destinationOffset.x, destinationOffset.y);
-        }
-        
-        if(clipDestRegion) {
-            // Now clip any negative destination offsets, i.e. clip
-            // to the top and left of the destination image
-            if (destRegion.x < 0) {
-                int delta = -destRegion.x*periodX;
-                srcRegion.x += delta;
-                srcRegion.width -= delta;
-                destRegion.x = 0;
-            }
-            if (destRegion.y < 0) {
-                int delta = -destRegion.y*periodY;
-                srcRegion.y += delta;
-                srcRegion.height -= delta;
-                destRegion.y = 0;
-            }
-        }
-
-        // Now clip the destination Region to the subsampled width and height
-        int subsampledWidth = (srcRegion.width + periodX - 1)/periodX;
-        int subsampledHeight = (srcRegion.height + periodY - 1)/periodY;
-        destRegion.width = subsampledWidth;
-        destRegion.height = subsampledHeight;
-
-        if (srcRegion.isEmpty() || destRegion.isEmpty()) {
-            throw new IllegalArgumentException
-                (I18N.getString("ImageReadOpImage1"));
-        }
-    }
-
-    /**
-     * XXX
-     * NB: This class may reset the following fields of the ImageReadParam
-     *     destinationOffset
-     *     destinationType
-     *     sourceRegion
-     */
-    ImageReadOpImage(ImageLayout layout,
-                     Map configuration,
-                     ImageReadParam param,
-                     ImageReader reader,
-                     int imageIndex,
-                     boolean readThumbnails,
-                     ImageInputStream streamToClose) throws IOException {
-        super(null,
-              layoutHelper(layout, param, reader, imageIndex),
-              configuration,
-              false);
-
-        // Revise parameter 'param' as needed.
-        if(param == null) {
-            // Get the ImageReadParam from the ImageReader.
-            param = reader.getDefaultReadParam();
-        } else if(param instanceof Cloneable) {
-            this.param = param;
-        } else if(param.getClass().getName().equals(
-                      "javax.imageio.ImageReadParam")) {
-            // The ImageReadParam passed in is non-null. As the
-            // ImageReadParam class is not Cloneable, if the param
-            // class is simply ImageReadParam, then create a new
-            // ImageReadParam instance and set all its fields
-            // which were set in param. This will eliminate problems
-            // with concurrent modification of param for the cases
-            // in which there is not a special ImageReadparam used.
-
-            // Create a new ImageReadParam instance.
-            ImageReadParam newParam = new ImageReadParam();
-
-            // Set all fields which need to be set.
-
-            // IIOParamController field.
-            if(param.hasController()) {
-                newParam.setController(param.getController());
-            }
-
-            // Destination fields.
-            newParam.setDestination(param.getDestination());
-            if(param.getDestinationType() != null) {
-                // Set the destination type only if non-null as the
-                // setDestinationType() clears the destination field.
-                newParam.setDestinationType(param.getDestinationType());
-            }
-            newParam.setDestinationBands(param.getDestinationBands());
-            newParam.setDestinationOffset(param.getDestinationOffset());
-
-            // Source fields.
-            newParam.setSourceBands(param.getSourceBands());
-            newParam.setSourceRegion(param.getSourceRegion());
-            if(param.getSourceMaxProgressivePass() != Integer.MAX_VALUE) {
-                newParam.setSourceProgressivePasses(
-                    param.getSourceMinProgressivePass(),
-                    param.getSourceNumProgressivePasses());
-            }
-            if(param.canSetSourceRenderSize()) {
-                newParam.setSourceRenderSize(param.getSourceRenderSize());
-            }
-            newParam.setSourceSubsampling(param.getSourceXSubsampling(),
-                                          param.getSourceYSubsampling(),
-                                          param.getSubsamplingXOffset(),
-                                          param.getSubsamplingYOffset());
-
-            // Replace the local variable with the new ImageReadParam.
-            param = newParam;
-        }
-
-        // Revise parameter 'readThumbnails' as needed.
-        if(readThumbnails && !reader.hasThumbnails(imageIndex)) {
-            // Unset thumbnail flag if not supported by ImageReader.
-            readThumbnails = false;
-        }
-
-        // Set instance variables from (possibly revised) parameters.
-        this.param = param;
-        this.reader = reader;
-        this.imageIndex = imageIndex;
-        this.readThumbnails = readThumbnails;
-        this.streamToClose = streamToClose;
-
-        // If an ImageTypeSpecifier is specified in the ImageReadParam
-        // but it is incompatible with the ImageReader, then attempt to
-        // replace it with a compatible one derived from this image.
-        if(param.getDestinationType() != null &&
-           !isCompatibleType(param.getDestinationType(), reader, imageIndex) &&
-           sampleModel != null && colorModel != null) {
-            ImageTypeSpecifier newImageType =
-                new ImageTypeSpecifier(colorModel,  sampleModel);
-            if(isCompatibleType(newImageType, reader, imageIndex)) {
-                param.setDestinationType(newImageType);
-            }
-        }
-
-        // --- Compute the destination to source mapping coefficients. ---
-
-        Dimension sourceSize = getSourceSize(param, reader, imageIndex);
-
-        Rectangle srcRegion = getSourceRegion(param,
-                                              sourceSize.width,
-                                              sourceSize.height);
-
-        Point destinationOffset = this.param.getDestinationOffset();
-
-        this.scaleX = this.param.getSourceXSubsampling();
-        this.scaleY = this.param.getSourceYSubsampling();
-        this.transX =
-            srcRegion.x + this.param.getSubsamplingXOffset() -
-            this.param.getSourceXSubsampling()*(minX + destinationOffset.x);
-        this.transY =
-            srcRegion.y + this.param.getSubsamplingYOffset() -
-            this.param.getSourceYSubsampling()*(minY + destinationOffset.y);
-
-        // Replace the original destination offset with (0,0) as the
-        // destination-to-source mapping assimilates this value.
-        this.param.setDestinationOffset(new Point());
-        // XXX Need to unset other ImageReadParam settings either here
-        // or in computeTile(). Examine this issue taking into account
-        // synchronization.
-
-        // Set the ImageReadParam property.
-        setProperty(ImageReadDescriptor.PROPERTY_NAME_IMAGE_READ_PARAM, param);
-
-        // Set the ImageReader property.
-        setProperty(ImageReadDescriptor.PROPERTY_NAME_IMAGE_READER, reader);
-
-        // If metadata are being read, set the value of the metadata
-        // properties to UndefinedProperty so that the property
-        // names will appear in the array of property names. The actual
-        // values will be retrieved when getProperty() is invoked.
-        if(!reader.isIgnoringMetadata()) {
-            // Get the service provider interface, if any.
-            ImageReaderSpi provider = reader.getOriginatingProvider();
-
-            // Stream metadata.
-            if(provider == null ||
-               provider.isStandardStreamMetadataFormatSupported() ||
-               provider.getNativeStreamMetadataFormatName() != null) {
-                // Assume an ImageReader with a null provider supports
-                // stream metadata.
-                setProperty(ImageReadDescriptor.PROPERTY_NAME_METADATA_STREAM,
-                            java.awt.Image.UndefinedProperty);
-            } else {
-                // Provider supports neither standard nor native stream
-                // metadata so set flag to suppress later reading attempt.
-                streamMetadataRead = true;
-            }
-
-            // Image metadata.
-            if(provider == null ||
-               provider.isStandardImageMetadataFormatSupported() ||
-               provider.getNativeImageMetadataFormatName() != null) {
-                // Assume an ImageReader with a null provider supports
-                // image metadata.
-                setProperty(ImageReadDescriptor.PROPERTY_NAME_METADATA_IMAGE,
-                            java.awt.Image.UndefinedProperty);
-            } else {
-                // Provider supports neither standard nor native image
-                // metadata so set flag to suppress later reading attempt.
-                imageMetadataRead = true;
-            }
-        }
-
-        // If thumbnail read flag is set, set the value of the thumbnail
-        // property to UndefinedProperty so that the thumbnail property
-        // name will appear in the array of property names. The actual
-        // value will be retrieved when getProperty() is invoked.
-        if(readThumbnails && reader.readerSupportsThumbnails()) {
-            setProperty(ImageReadDescriptor.PROPERTY_NAME_THUMBNAILS,
-                        java.awt.Image.UndefinedProperty);
-        }
-    }
-
-    /**
-     * Returns false as ImageReaders might return Rasters
-     * via computeTile() tile that are internally cached.
-     */
-    public boolean computesUniqueTiles() {
-        return false;
-    }
-
-    /**
-     * XXX
-     */
-    private Rectangle computeSourceRect(Rectangle destRect) {
-        Rectangle sourceRect = new Rectangle();
-
-        sourceRect.x = scaleX*destRect.x + transX;
-        sourceRect.y = scaleY*destRect.y + transY;
-
-        sourceRect.width =
-            scaleX*(destRect.x + destRect.width) + transX - sourceRect.x;
-        sourceRect.height =
-            scaleY*(destRect.y + destRect.height) + transY - sourceRect.y;
-
-        return sourceRect;
-    }
-
-    /**
-     * Computes a tile.
-     *
-     * @param tileX The X index of the tile.
-     * @param tileY The Y index of the tile.
-     */
-    public Raster computeTile(int tileX, int tileY) {
-        //XXX System.out.println("Tile ("+tileX+","+tileY+")");
-        // Create a new WritableRaster to represent this tile.
-        Point org = new Point(tileXToX(tileX), tileYToY(tileY));
-        //WritableRaster dest = Raster.createWritableRaster(sampleModel, org);
-        Rectangle rect = new Rectangle(org.x, org.y, tileWidth, tileHeight);
-
-        // Clip output rectangle to image bounds.
-        // Not sure what will happen here with the bounds intersection.
-        Rectangle destRect = rect.intersection(getBounds());
-        // XXX Check for destRect.isEmpty()?
-
-        /* XXX delete
-        java.awt.geom.AffineTransform transform =
-            new java.awt.geom.AffineTransform(scaleX, 0, 0, scaleY,
-                                              transX, transY);
-        */
-        Rectangle srcRect =
-            computeSourceRect(destRect);
-            /* XXX delete
-            transform.createTransformedShape(destRect).getBounds();
-            */
-
-        WritableRaster readerTile = null;
-        try {
-            synchronized(reader) {
-                param.setSourceRegion(srcRect);
-                BufferedImage bi = reader.read(imageIndex, param);
-                WritableRaster ras = bi.getRaster();
-                readerTile = ras.createWritableChild(0, 0,
-                                                     ras.getWidth(),
-                                                     ras.getHeight(),
-                                                     org.x, org.y,
-                                                     null);
-            }
-        } catch(IOException e) {
-            throw new RuntimeException(e);
-        }
-
-        WritableRaster tile = null;
-        if(sampleModel == readerTile.getSampleModel()) {
-            tile = readerTile;
-        } else {
-            // XXX As this method is synchronized, could a single
-            // destination be supplied to the reader instead of
-            // creating a new one?
-            tile = Raster.createWritableRaster(sampleModel, org);
-            tile.setRect(readerTile);
-        }
-
-        return tile;
-    }
-    
-    /**
-     * Throws an IllegalArgumentException since the image has no image
-     * sources.
-     *
-     * @param sourceRect ignored.
-     * @param sourceIndex ignored.
-     *
-     * @throws IllegalArgumentException since the image has no sources.
-     */
-    public Rectangle mapSourceRect(Rectangle sourceRect,
-                                   int sourceIndex) {
-        throw new IllegalArgumentException
-            (I18N.getString("ImageReadOpImage2"));
-    }
-    
-    /**
-     * Throws an IllegalArgumentException since the image has no image
-     * sources.
-     *
-     * @param destRect ignored.
-     * @param sourceIndex ignored.
-     *
-     * @throws IllegalArgumentException since the image has no sources.
-     */
-    public Rectangle mapDestRect(Rectangle destRect,
-                                 int sourceIndex) {
-        throw new IllegalArgumentException
-            (I18N.getString("ImageReadOpImage2"));
-    }
-
-    /**
-     * Gets a property from the property set of this image.  If the
-     * property name is not recognized,
-     * <code>java.awt.Image.UndefinedProperty</code> will be returned.
-     *
-     * <p>This implementation first attempts to retrieve the property
-     * using the equivalent superclass method.  If the returned value
-     * is not a valid property value, the requested property name is
-     * that of the image thumbnails property, the stream metadata
-     * property, or the image metadata property, and there has been no
-     * prior attempt to read the corresponding property value, then its
-     * reads the value and set the property.  This implementation therefore
-     * defers reading of the image thumbnails, stream metadata, and image
-     * metadata values until the correpsonding property is actually
-     * requested.</p>
-     *
-     * @param name the name of the property to get, as a <code>String</code>.
-     *
-     * @return A reference to the property <code>Object</code>, or the value
-     *         <code>java.awt.Image.UndefinedProperty</code>.
-     *
-     * @exception IllegalArgumentException if <code>propertyName</code>
-     *                                     is <code>null</code>.
-     */
-    public Object getProperty(String name) {
-        // Attempt to get property from superclass method.
-        Object property = super.getProperty(name);
-
-        // If thumbnail property name with undefined value and thumbnails
-        // are being read and an attempt to read them has not already been
-        // made, then read the thumbnails and set the property.
-        if((property == null ||
-            property == java.awt.Image.UndefinedProperty)) {
-
-            // Thumbnails
-            if(readThumbnails &&
-               name.equalsIgnoreCase(
-                   ImageReadDescriptor.PROPERTY_NAME_THUMBNAILS)) {
-
-                // Lock the class to avoid a race condition here
-                // and with computeTile().
-                synchronized(reader) {
-                    // First re-check the flag in case another thread
-                    // got here first.
-                    if(readThumbnails) {
-                        try {
-                            // Get number of thumbnails.
-                            int numThumbnails =
-                                reader.getNumThumbnails(imageIndex);
-
-                            if(numThumbnails > 0) {
-                                // Read all thumbnails.
-                                BufferedImage[] thumbnails =
-                                    new BufferedImage[numThumbnails];
-                                for(int i = 0; i < numThumbnails; i++) {
-                                    thumbnails[i] =
-                                        reader.readThumbnail(imageIndex, i);
-                                }
-
-                                // Set thumbnail property.
-                                setProperty(
-                                  ImageReadDescriptor.PROPERTY_NAME_THUMBNAILS,
-                                  thumbnails);
-
-                                // Update return value.
-                                property = thumbnails;
-                            }
-                        } catch(IOException e) {
-                            throw new RuntimeException(e);
-                        } finally {
-                            // If return value is somehow null set it
-                            // to UndefinedProperty.
-                            if(property == null) {
-                                property = java.awt.Image.UndefinedProperty;
-                            }
-
-                            // Unset thumbnail flag to avert subsequent
-                            // reading attempts in case this one failed.
-                            readThumbnails = false;
-                        }
-                    }
-                }
-            } else if(!reader.isIgnoringMetadata() &&
-                      ((!streamMetadataRead &&
-                        name.equalsIgnoreCase(
-                         ImageReadDescriptor.PROPERTY_NAME_METADATA_STREAM)) ||
-                       (!imageMetadataRead &&
-                        name.equalsIgnoreCase(
-                         ImageReadDescriptor.PROPERTY_NAME_METADATA_IMAGE)))) {
-
-                // Lock the class to avoid a race condition here
-                // and with computeTile().
-                synchronized(reader) {
-
-                    // Set flag to indicate stream or image metadata.
-                    boolean isStreamMetadata =
-                        name.equalsIgnoreCase(
-                            ImageReadDescriptor.PROPERTY_NAME_METADATA_STREAM);
-
-                    // Recheck the appropriate flag.
-                    if(!(isStreamMetadata ?
-                         streamMetadataRead : imageMetadataRead)) {
-
-                        // Set property name.
-                        String propertyName = isStreamMetadata ?
-                            ImageReadDescriptor.PROPERTY_NAME_METADATA_STREAM :
-                            ImageReadDescriptor.PROPERTY_NAME_METADATA_IMAGE;
-
-                        IIOMetadata metadata = null;
-                        try {
-                            // Read metadata.
-                            metadata = isStreamMetadata ?
-                                reader.getStreamMetadata() :
-                                reader.getImageMetadata(imageIndex);
-
-                            // Set metadata property.
-                            if(metadata != null) {
-                                setProperty(propertyName, metadata);
-                            }
-
-                            // Update return value.
-                            property = metadata;
-                        } catch(IOException e) {
-                            throw new RuntimeException(e);
-                        } finally {
-                            // If return value is somehow null set it
-                            // to UndefinedProperty.
-                            if(property == null) {
-                                property = java.awt.Image.UndefinedProperty;
-                            }
-
-                            // Set appropriate flag to avert subsequent
-                            // reading attempts in case this one failed.
-                            if(isStreamMetadata) {
-                                streamMetadataRead = true;
-                            } else {
-                                imageMetadataRead = true;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return property;
-    }
-
-    /**
-     * Closes an <code>ImageInputStream</code> passed in, if any.
-     */
-    public void dispose() {
-        if(streamToClose != null) {
-            try {
-                streamToClose.close();
-            } catch(IOException e) {
-                // Ignore it.
-            }
-        }
-
-        super.dispose();
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadWriteSpi.java zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadWriteSpi.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadWriteSpi.java	2005-02-11 00:01:55.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageReadWriteSpi.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,142 +0,0 @@
-/*
- * $RCSfile: ImageReadWriteSpi.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:55 $
- * $State: Exp $
- */
-package com.sun.media.jai.imageioimpl;
-
-import java.awt.image.renderable.ContextualRenderedImageFactory;
-import javax.media.jai.CollectionImageFactory;
-import javax.media.jai.OperationDescriptor;
-import javax.media.jai.OperationRegistry;
-import javax.media.jai.OperationRegistrySpi;
-import com.sun.media.jai.operator.ImageReadDescriptor;
-import com.sun.media.jai.operator.ImageWriteDescriptor;
-import javax.media.jai.registry.CollectionRegistryMode;
-import javax.media.jai.registry.RenderableRegistryMode;
-import javax.media.jai.registry.RenderedRegistryMode;
-
-/**
- * {@link OperationRegistrySpi} implementation to register the "ImageRead"
- * and "ImageWrite" operations and their associated image factories.
- */
-public class ImageReadWriteSpi implements OperationRegistrySpi {
-
-    /** The name of the product to which these operations belong. */
-    private String productName = "com.sun.media.jai";
- 
-    /** Default constructor. */
-    public ImageReadWriteSpi() {}
-
-    /**
-     * Registers the "ImageRead" and "ImageWrite" operations and their
-     * associated image factories across all supported operation modes.
-     * An {@link OperationDescriptor} is created for each operation and
-     * registered with the supplied {@link OperationRegistry}. An image
-     * factory is then created for each supported mode of each operation
-     * registered for that operation with the registry.
-     *
-     * @param registry The registry with which to register the operations
-     * and their factories.
-     */
-    public void updateRegistry(OperationRegistry registry) {
-        // Create the "ImageRead" descriptor instance.
-        OperationDescriptor readDescriptor = new ImageReadDescriptor();
-
-        // Register the "ImageRead" descriptor.
-        registry.registerDescriptor(readDescriptor);
-
-        // Create the "ImageRead" CRIF.
-        ContextualRenderedImageFactory readCRIF = new ImageReadCRIF();
-
-        // Get the "ImageRead" operation name.
-        String imageReadName = readDescriptor.getName();
-
-        // Register the "ImageRead" factory for rendered mode.
-        registry.registerFactory(RenderedRegistryMode.MODE_NAME,
-                                 imageReadName,
-                                 productName,
-                                 readCRIF);
-
-        // Register the "ImageRead" factory for renderable mode.
-        registry.registerFactory(RenderableRegistryMode.MODE_NAME,
-                                 imageReadName,
-                                 productName,
-                                 readCRIF);
-
-        // Create and register the "ImageRead" factory for collection mode.
-        registry.registerFactory(CollectionRegistryMode.MODE_NAME,
-                                 imageReadName,
-                                 productName,
-                                 new ImageReadCIF());
-
-        // Create the "ImageWrite" descriptor instance.
-        OperationDescriptor writeDescriptor = new ImageWriteDescriptor();
-
-        // Register the "ImageWrite" descriptor.
-        registry.registerDescriptor(writeDescriptor);
-
-        // Create the "ImageWrite" CRIF.
-        ContextualRenderedImageFactory writeCRIF = new ImageWriteCRIF();
-
-        // Get the "ImageWrite" operation name.
-        String imageWriteName = writeDescriptor.getName();
-
-        // Register the "ImageWrite" factory for rendered mode.
-        registry.registerFactory(RenderedRegistryMode.MODE_NAME,
-                                 imageWriteName,
-                                 productName,
-                                 writeCRIF);
-
-        // Register the "ImageWrite" factory for renderable mode.
-        registry.registerFactory(RenderableRegistryMode.MODE_NAME,
-                                 imageWriteName,
-                                 productName,
-                                 writeCRIF);
-
-        // Create and register the "ImageWrite" factory for collection mode.
-        registry.registerFactory(CollectionRegistryMode.MODE_NAME,
-                                 imageWriteName,
-                                 productName,
-                                 new ImageWriteCIF());
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageWriteCIF.java zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageWriteCIF.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageWriteCIF.java	2005-02-11 00:01:55.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageWriteCIF.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,296 +0,0 @@
-/*
- * $RCSfile: ImageWriteCIF.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:55 $
- * $State: Exp $
- */
-package com.sun.media.jai.imageioimpl;
-
-import java.awt.RenderingHints;
-import java.awt.image.BufferedImage;
-import java.awt.image.RenderedImage;
-import java.awt.image.renderable.ParameterBlock;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import javax.imageio.ImageIO;
-import javax.imageio.ImageWriteParam;
-import javax.imageio.ImageWriter;
-import javax.imageio.metadata.IIOMetadata;
-import javax.imageio.stream.ImageOutputStream;
-import javax.media.jai.CollectionImage;
-import javax.media.jai.CollectionImageFactory;
-import javax.media.jai.CollectionOp;
-import javax.media.jai.PropertySource;
-import com.sun.media.jai.operator.ImageWriteDescriptor;
-
-public final class ImageWriteCIF implements CollectionImageFactory {
-    /** Constructor. */
-    public ImageWriteCIF() {}
-
-    public CollectionImage create(ParameterBlock args,
-                                  RenderingHints hints) {
-
-        // Get the writer.
-        ImageWriter writer = (ImageWriter)args.getObjectParameter(13);
-
-        // Find a writer if null.
-        if(writer == null) {
-            // Get the format. Should be non-null from OperationDescriptor.
-            String format = (String)args.getObjectParameter(1);
-
-            // Find a writer.
-            Iterator writers = ImageIO.getImageWritersByFormatName(format);
-
-            // Get the writer.
-            if(writers != null) {
-                writer = (ImageWriter)writers.next();
-            } else {
-                throw new RuntimeException
-                    (I18N.getString("ImageWriteCIF0")+" "+format);
-            }
-        }
-
-        // Get the source Collection.
-        Collection collection = (Collection)args.getSource(0);
-
-        // Determine the number of RenderedImages in the Collection.
-        int numRenderedImages = 0;
-        Iterator iter = collection.iterator();
-        while(iter.hasNext()) {
-            if(iter.next() instanceof RenderedImage) {
-                numRenderedImages++;
-            }
-        }
-
-        // Set the sequence flag.
-        boolean writeToSequence = writer.canWriteSequence();
-
-        // Check that the writer can write sequences.
-        if(numRenderedImages > 1 && !writeToSequence) {
-            throw new RuntimeException
-                (I18N.getString("ImageWriteCIF1"));
-        }
-
-        // Get the stream metadata.
-        IIOMetadata streamMetadata =
-            (IIOMetadata)args.getObjectParameter(7);
-
-        // Get the property use flag.
-        boolean useProperties =
-            ((Boolean)args.getObjectParameter(2)).booleanValue();
-
-        // If null, get stream metadata from source properties if allowed.
-        if(streamMetadata == null &&
-           useProperties &&
-           collection instanceof PropertySource) {
-            Object streamMetadataProperty =
-                ((PropertySource)collection).getProperty(
-                    ImageWriteDescriptor.PROPERTY_NAME_METADATA_STREAM);
-            if(streamMetadataProperty instanceof IIOMetadata) {
-                streamMetadata = (IIOMetadata)streamMetadataProperty;
-            }
-        }
-
-        // Get the writer parameters.
-        ImageWriteParam param = (ImageWriteParam)args.getObjectParameter(12);
-
-        // Transcode the stream metadata if requested.
-        if(streamMetadata != null) {
-            // Get the transcoding flag.
-            boolean transcode =
-                ((Boolean)args.getObjectParameter(3)).booleanValue();
-
-            if(transcode) {
-                // Overwrite the stream metadata with transcoded metadata.
-                streamMetadata =
-                    writer.convertStreamMetadata(streamMetadata,
-                                                 param);
-            }
-        }
-
-        if(writeToSequence) {
-            // Write the stream metadata to the sequence.
-            try {
-                // Get the output.
-                Object output = args.getObjectParameter(0);
-
-                // Try to get an ImageOutputStream.
-                ImageOutputStream stream =
-                    ImageWriteCRIF.getImageOutputStream(output);
-
-                // Set the writer's output.
-                writer.setOutput(stream != null ? stream : output);
-
-                // Prepare the sequence.
-                writer.prepareWriteSequence(streamMetadata);
-            } catch(IOException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        // Clone the ParameterBlock as the writer, image metadata, and
-        // thumbnail parameters will be replaced.
-        ParameterBlock imagePB = (ParameterBlock)args.clone();
-
-        // Clear the stream metadata.
-        imagePB.set(null, 7);
-
-        // Set the ImageWriter.
-        imagePB.set(writer, 13);
-
-        // Get the image metadata array.
-        IIOMetadata[] imageMetadata =
-            (IIOMetadata[])args.getObjectParameter(8);
-
-        // Get the thumbnail array.
-        BufferedImage[] thumbnails =
-            (BufferedImage[])args.getObjectParameter(9);
-
-        // Create a new Iterator.
-        iter = collection.iterator();
-
-        // Create an ImageIOCollectionImage to contain the result:
-        ImageIOCollectionImage imageList =
-            new ImageIOCollectionImage(collection.size());
-
-        // Iterate over the collection.
-        int imageIndex = 0;
-        while(iter.hasNext()) {
-            // Get the next element.
-            Object nextElement = iter.next();
-
-            // Process if a RenderedImage.
-            if(nextElement instanceof RenderedImage) {
-                // Replace source with current RenderedImage.
-                imagePB.setSource((RenderedImage)nextElement, 0);
-
-                // Replace image metadata.
-                if(imageMetadata != null) {
-                    imagePB.set(imageMetadata[imageIndex], 8);
-                }
-
-                // Replace thumbnail array.
-                if(thumbnails != null) {
-                    imagePB.set(thumbnails[imageIndex], 9);
-                }
-
-                // Write the image to the sequence
-                RenderedImage nextImage =
-                    ImageWriteCRIF.create(imageIndex,
-                                          writeToSequence,
-                                          imagePB, hints);
-
-                // If the ImageWriteParam passed in was null, replace it
-                // with the first non-null ImageWriteParam property value
-                // and set the value in the local ParameterBlock.
-                if(param == null) {
-                    Object paramPropertyValue =
-                        nextImage.getProperty(
-                        ImageWriteDescriptor.PROPERTY_NAME_IMAGE_WRITE_PARAM);
-
-                    if(paramPropertyValue instanceof ImageWriteParam) {
-                        param = (ImageWriteParam)paramPropertyValue;
-
-                        // Replace the ImageWriteParam so the CRIF doesn't
-                        // have to re-do the tile size initialization.
-                        imagePB.set(param, 12);
-                    }
-                }
-
-                // Add the image to the collection to be returned.
-                imageList.add(nextImage);
-
-                // Increment the index.
-                imageIndex++;
-            }
-        }
-
-        // Get the pixel replacement parameter.
-        boolean allowPixelReplacement =
-            ((Boolean)args.getObjectParameter(5)).booleanValue();
-
-        if(writeToSequence && !allowPixelReplacement) {
-            // Complete writing the sequence.
-            try {
-                // XXX What about pixel replacement? If this is invoked here
-                // it will not be possible. How can this be invoked such that
-                // pixel replacement can occur but the user is not obliged to
-                // call this method manually?
-                // Answer: document that the user must obtain the writer from
-                // the collection-level ImageWriter property and invoke
-                // endWriteSequence() on it.
-                writer.endWriteSequence();
-            } catch(IOException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        // Set collection-level properties.
-        if(param != null) {
-            imageList.setProperty(
-                ImageWriteDescriptor.PROPERTY_NAME_IMAGE_WRITE_PARAM,
-                param);
-        }
-        imageList.setProperty(
-            ImageWriteDescriptor.PROPERTY_NAME_IMAGE_WRITER,
-            writer);
-        if(streamMetadata != null) {
-            imageList.setProperty(
-                ImageWriteDescriptor.PROPERTY_NAME_METADATA_STREAM,
-                streamMetadata);
-        }
-
-        // Return CollectionImage.
-        return imageList;
-    }
-
-    // Forget it.
-    public CollectionImage update(ParameterBlock oldParamBlock,
-                                  RenderingHints oldHints,
-                                  ParameterBlock newParamBlock,
-                                  RenderingHints newHints,
-                                  CollectionImage oldRendering,
-                                  CollectionOp op) {
-        return null;
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageWriteCRIF.java zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageWriteCRIF.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/ImageWriteCRIF.java	2005-02-11 00:01:55.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/ImageWriteCRIF.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,663 +0,0 @@
-/*
- * $RCSfile: ImageWriteCRIF.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:55 $
- * $State: Exp $
- */
-package com.sun.media.jai.imageioimpl;
-
-import java.awt.Dimension;
-import java.awt.RenderingHints;
-import java.awt.image.BufferedImage;
-import java.awt.image.RenderedImage;
-import java.awt.image.renderable.ParameterBlock;
-import java.awt.image.renderable.RenderableImage;
-import java.awt.image.renderable.RenderContext;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.RandomAccessFile;
-import java.net.Socket;
-import java.util.Arrays;
-import java.util.EventListener;
-import java.util.Iterator;
-import java.util.Locale;
-import javax.imageio.IIOImage;
-import javax.imageio.ImageIO;
-import javax.imageio.ImageTypeSpecifier;
-import javax.imageio.ImageWriter;
-import javax.imageio.ImageWriteParam;
-import javax.imageio.event.IIOWriteProgressListener;
-import javax.imageio.event.IIOWriteWarningListener;
-import javax.imageio.metadata.IIOMetadata;
-import javax.imageio.stream.ImageOutputStream;
-import javax.media.jai.CRIFImpl;
-import javax.media.jai.PlanarImage;
-import javax.media.jai.RenderedImageAdapter;
-import javax.media.jai.WritablePropertySource;
-import com.sun.media.jai.operator.ImageWriteDescriptor;
-
-public final class ImageWriteCRIF extends CRIFImpl {
-    public static void main(String[] args) throws Throwable {
-        java.io.File inFile = new java.io.File(args[0]);
-        java.io.File outFile = new java.io.File(args[1]);
-        String format = args.length > 2 ? args[2] : "png";
-        String mode = args.length > 3 ? args[3] : "rendered";
-
-        int imageIndex = 0;
-
-        javax.imageio.stream.ImageInputStream inStream =
-            javax.imageio.ImageIO.createImageInputStream(inFile);
-
-        java.util.Iterator iter =
-            javax.imageio.ImageIO.getImageReaders(inStream);
-        javax.imageio.ImageReader reader =
-            (javax.imageio.ImageReader)iter.next();
-
-        reader.setInput(inStream);
-
-        RenderedImage image = reader.read(imageIndex);
-
-        javax.imageio.metadata.IIOMetadata streamMetadata =
-            reader.getStreamMetadata();
-        javax.imageio.metadata.IIOMetadata imageMetadata =
-            reader.getImageMetadata(imageIndex);
-
-        java.awt.image.BufferedImage[] thumbnails = null;
-        if(reader.hasThumbnails(imageIndex)) {
-            int numThumbnails = reader.getNumThumbnails(imageIndex);
-            thumbnails = new java.awt.image.BufferedImage[numThumbnails];
-            for(int i = 0; i < numThumbnails; i++) {
-                thumbnails[i] = reader.readThumbnail(imageIndex, i);
-            }
-        }
-
-        ImageWriteCRIF crif = new ImageWriteCRIF();
-
-        ParameterBlock pb = new ParameterBlock();
-
-        if(mode.equalsIgnoreCase("rendered")) {
-            pb.addSource(image);
-        } else if(mode.equalsIgnoreCase("renderable")) {
-            ParameterBlock renderablePB = new ParameterBlock();
-            renderablePB.addSource(image);
-            RenderableImage renderable =
-                javax.media.jai.JAI.createRenderable("renderable",
-                                                     renderablePB);
-            pb.addSource(renderable);
-        }
-
-        pb.add(outFile); // Output
-        pb.add(format); // Format
-
-        pb.add(Boolean.TRUE); // UseProperties
-        pb.add(Boolean.TRUE); // Transcode
-        pb.add(Boolean.TRUE); // VerifyOutput
-        pb.add(Boolean.TRUE); // AllowPixelReplacement
-
-        pb.add(null); // TileSize
-
-        pb.add(streamMetadata);
-        pb.add(imageMetadata);
-        pb.add(thumbnails);
-
-        pb.add(null); // EventListener[]
-        pb.add(null); // Locale
-
-        pb.add(null); // ImageWriteParam
-        pb.add(null); // ImageWriter
-
-        if(mode.equalsIgnoreCase("rendered")) {
-            crif.create(pb, null);
-        } else if(mode.equalsIgnoreCase("renderable")) {
-            java.awt.geom.AffineTransform transform =
-                new java.awt.geom.AffineTransform(256, 0, 0, 512, 0, 0);
-            crif.create(new RenderContext(transform), pb);
-        }
-    }
-
-    public ImageWriteCRIF() {
-        super();
-    }
-
-    /**
-     * Attempt to create an {@link ImageOutputStream} for the supplied
-     * output. The following sequence is effected:
-     * <ol>
-     * <li><ul>
-     * <li>If <code>output</code> is an <code>ImageOutputStream</code> it
-     * is cast and returned.</li>
-     * <li>If <code>output</code> is a <code>String</code> it is converted
-     * to a read-write <code>RandomAccessFile</code>.</li>
-     * <li>If <code>output</code> is a <code>Socket</code> it is converted
-     * to an <code>OutputStream</code>.</li>
-     * </ul></li>
-     * <li><code>ImageIO.createImageOutputStream()</code> is invoked
-     * with parameter set to the (possibly converted) output and the
-     * value it returns (which could be <code>null</code>) is returned
-     * to the caller.</li>
-     * </ol>
-     *
-     * @param output An <code>Object</code> to be used as the destination,
-     * such as a <code>String</code>, <code>File</code>, writable
-     * <code>RandomAccessFile</code>, <code>OutputStream</code>, writable
-     * <code>Socket</code>, or writable <code>Channel</code>.
-     *
-     * @return An <code>ImageOutputStream</code> or <code>null</code>.
-     */
-    static ImageOutputStream getImageOutputStream(Object output) {
-        // The value to be returned.
-        ImageOutputStream stream = null;
-
-        // If already an ImageOutputStream just cast.
-        if(output instanceof ImageOutputStream) {
-            stream = (ImageOutputStream)output;
-        } else {
-            if(output instanceof String) {
-                // If output is a String replace it with a RandomAccessFile.
-                try {
-                    // 'output' is conditionally checked for writability
-                    // in the OperationDescriptor.
-                    output = new RandomAccessFile((String)output, "rw");
-                } catch(Exception e) {
-                    throw new RuntimeException
-                        (I18N.getString("ImageWriteCRIF0")+" "+output);
-                }
-            } else if(output instanceof Socket) {
-                // If output is a Socket replace it with an OutputStream.
-                try {
-                    // XXX check binding, connection, closed, shutdown
-                    // as these could have changed.
-                    output = ((Socket)output).getOutputStream();
-                } catch(Exception e) {
-                    throw new RuntimeException
-                        (I18N.getString("ImageWriteCRIF1")+" "+output);
-                }
-            }
-
-            // Create the ImageOutputStream.
-            try {
-                stream = ImageIO.createImageOutputStream(output);
-            } catch(IOException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        return stream;
-    }
-
-    /**
-     * {@link RenderedImageFactory} implementation.
-     */
-    public RenderedImage create(ParameterBlock pb,
-                                RenderingHints rh) {
-        return create(0, false, pb, rh);
-    }
-
-    private static ImageWriteParam getWriteParam(ImageWriteParam param,
-                                                 ImageWriter writer) {
-        // Set default to original ImageWriteParam.
-        ImageWriteParam newParam = param;
-
-        if(param == null) {
-            newParam = writer.getDefaultWriteParam();
-        } else if(param.getClass().getName().equals(
-                      "javax.imageio.ImageWriteParam")) {
-            // The ImageWriteParam passed in is non-null. As the
-            // ImageWriteParam class is not Cloneable, if the param
-            // class is simply ImageWriteParam, then create a new
-            // ImageWriteParam instance and set all its fields
-            // which were set in param. This will eliminate problems
-            // with concurrent modification of param for the cases
-            // in which there is not a special ImageWriteParam used.
-
-            // Create a new ImageWriteParam instance.
-            newParam = writer.getDefaultWriteParam();
-
-            // Set all fields which need to be set.
-
-            // IIOParamController field.
-            if(param.hasController()) {
-                newParam.setController(param.getController());
-            }
-
-            // Destination fields.
-            newParam.setDestinationOffset(param.getDestinationOffset());
-            newParam.setDestinationType(param.getDestinationType());
-
-            // Source fields.
-            newParam.setSourceBands(param.getSourceBands());
-            newParam.setSourceRegion(param.getSourceRegion());
-            newParam.setSourceSubsampling(param.getSourceXSubsampling(),
-                                          param.getSourceYSubsampling(),
-                                          param.getSubsamplingXOffset(),
-                                          param.getSubsamplingYOffset());
-
-            // Compression.
-            if(param.canWriteCompressed()) {
-                int compressionMode = param.getCompressionMode();
-                newParam.setCompressionMode(compressionMode);
-                if(compressionMode == ImageWriteParam.MODE_EXPLICIT) {
-                    newParam.setCompressionQuality(param.getCompressionQuality());
-                    newParam.setCompressionType(param.getCompressionType());
-                }
-            }
-
-            // Progressive
-            if(param.canWriteProgressive()) {
-                newParam.setProgressiveMode(param.getProgressiveMode());
-            }
-
-            // Tiling
-            if(param.canWriteTiles()) {
-                int tilingMode = param.getTilingMode();
-                newParam.setTilingMode(tilingMode);
-                if(tilingMode == ImageWriteParam.MODE_EXPLICIT) {
-                    newParam.setTiling(param.getTileWidth(),
-                                       param.getTileHeight(),
-                                       param.getTileGridXOffset(),
-                                       param.getTileGridYOffset());
-                }
-            }
-        }
-
-        return newParam;
-    }
-
-    /**
-     * If tiling is supported, determine the appropriate tile size and
-     * set it on the returned param if necessary. The returned param
-     * will either be a new ImageWriteParam or the one passed in with
-     * its tiling settings possibly modified.
-     */
-    private static ImageWriteParam setTileSize(ImageWriteParam param,
-                                               ImageWriter writer,
-                                               Dimension tileSize,
-                                               RenderedImage source) {
-
-        ImageWriteParam returnParam = getWriteParam(param, writer);
-
-        // If tiling possible set tile size if needed.
-        if(returnParam.canWriteTiles()) {
-            if(tileSize != null) {
-                // Check tile size.
-                if(tileSize.width <= 0 || tileSize.height <= 0) {
-                    throw new IllegalArgumentException
-                        ("tileSize.width <= 0 || tileSize.height <= 0");
-                }
-
-                // Use specified tile size.
-                returnParam.setTilingMode(ImageWriteParam.MODE_EXPLICIT);
-                returnParam.setTiling(tileSize.width,
-                                      tileSize.height,
-                                      0, 0); // XXX set tile offsets?
-            } else if(param == null) {
-                if(source.getNumXTiles() > 1 || source.getNumYTiles() > 1) {
-                    // Null tile size and param args: use source tile size.
-                    returnParam.setTilingMode(ImageWriteParam.MODE_EXPLICIT);
-                    returnParam.setTiling(source.getTileWidth(),
-                                          source.getTileHeight(),
-                                          0, 0); // XXX set tile offsets?
-                }
-            } else if(returnParam.getTilingMode() ==
-                      ImageWriteParam.MODE_EXPLICIT) {
-                // Param passed in has explicit mode set but the tile
-                // grid might not actually be set.
-                boolean setTileSize = false;
-
-                // Save reference to preferred tile size array.
-                Dimension[] preferredTileSizes =
-                    returnParam.getPreferredTileSizes();
-
-                // Set the tile width.
-                int tileWidth = 0;
-                try {
-                    // Try to get it from the param.
-                    tileWidth = returnParam.getTileWidth();
-                } catch(IllegalStateException e) {
-                    // Not set in the param.
-                    setTileSize = true;
-
-                    if(preferredTileSizes != null &&
-                       preferredTileSizes.length >= 2 &&
-                       preferredTileSizes[0].width > 0 &&
-                       preferredTileSizes[1].width > 0) {
-                        // Use average of first two preferred tile widths.
-                        tileWidth = (preferredTileSizes[0].width +
-                                     preferredTileSizes[1].width) / 2;
-                    } else {
-                        // Use source image tile width.
-                        tileWidth = source.getTileWidth();
-                    }
-                }
-
-                // Set the tile height.
-                int tileHeight = 0;
-                try {
-                    // Try to get it from the param.
-                    tileHeight = returnParam.getTileHeight();
-                } catch(IllegalStateException e) {
-                    // Not set in the param.
-                    setTileSize = true;
-
-                    if(preferredTileSizes != null &&
-                       preferredTileSizes.length >= 2 &&
-                       preferredTileSizes[0].height > 0 &&
-                       preferredTileSizes[1].height > 0) {
-                        // Use average of first two preferred tile heights.
-                        tileHeight = (preferredTileSizes[0].height +
-                                      preferredTileSizes[1].height) / 2;
-                    } else {
-                        // Use source image tile height.
-                        tileHeight = source.getTileHeight();
-                    }
-                }
-
-                // Set the tile size if not previously set in the param.
-                if(setTileSize) {
-                    returnParam.setTiling(tileWidth,
-                                          tileHeight,
-                                          0, 0); // XXX set tile offsets?
-                }
-            }
-        }
-
-        return returnParam;
-    }
-
-    static RenderedImage create(int imageIndex,
-                                boolean writeToSequence,
-                                ParameterBlock pb,
-                                RenderingHints rh) {
-
-        // Value to be returned.
-        RenderedImage image = null;
-
-        // Get the source image.
-        RenderedImage source = pb.getRenderedSource(0);
-
-        // Get the writer parameters.
-        ImageWriteParam param = (ImageWriteParam)pb.getObjectParameter(12);
-
-        // Set the target image type.
-        ImageTypeSpecifier destinationType = null;
-        if(param != null) {
-            destinationType = param.getDestinationType();
-        }
-        if(destinationType == null) {
-            destinationType = new ImageTypeSpecifier(source);
-        }
-
-        // Get the writer.
-        ImageWriter writer = (ImageWriter)pb.getObjectParameter(13);
-
-        if(writer == null) {
-            // Get the format. Should be non-null from OperationDescriptor.
-            String format = (String)pb.getObjectParameter(1);
-
-            // Find a writer.
-            Iterator writers = ImageIO.getImageWriters(destinationType,
-                                                       format);
-
-            // Get the writer.
-            if(writers != null && writers.hasNext()) {
-                writer = (ImageWriter)writers.next();
-            }
-        }
-
-        // XXX What if no writer? Exception?
-        if(writer != null) {
-            // XXX Replace ImageWriter parameter in ParameterBlock?
-
-            ImageOutputStream streamToClose = null;
-
-            // Set the output if not writing to a sequence (in which
-            // case the output should already be set.
-            if(!writeToSequence) {
-                // Get the output.
-                Object output = pb.getObjectParameter(0);
-
-                // Try to get an ImageOutputStream.
-                ImageOutputStream stream = getImageOutputStream(output);
-
-                // Set stream to close if not writing to a sequence.
-                streamToClose = stream != output ? stream : null;
-
-                // Set the writer's output.
-                writer.setOutput(stream != null ? stream : output);
-            }
-
-            // Get the property use flag.
-            boolean useProperties =
-                ((Boolean)pb.getObjectParameter(2)).booleanValue();
-
-            // Get the transcoding flag.
-            boolean transcode =
-                ((Boolean)pb.getObjectParameter(3)).booleanValue();
-
-            IIOMetadata streamMetadata = null;
-            if(!writeToSequence) {
-                // Get the stream metadata.
-                streamMetadata = (IIOMetadata)pb.getObjectParameter(7);
-
-                // If null, get stream metadata from source properties
-                // if allowed.
-                if(streamMetadata == null && useProperties) {
-                    Object streamMetadataProperty =
-                        source.getProperty(
-                            ImageWriteDescriptor.PROPERTY_NAME_METADATA_STREAM);
-                    if(streamMetadataProperty instanceof IIOMetadata) {
-                        streamMetadata = (IIOMetadata)streamMetadataProperty;
-                    }
-                }
-
-                // Transcode the stream metadata if requested.
-                if(streamMetadata != null && transcode) {
-                    // Overwrite the stream metadata with transcoded metadata.
-                    streamMetadata =
-                        writer.convertStreamMetadata(streamMetadata,
-                                                     param);
-                }
-            }
-
-            // Get the image metadata.
-            IIOMetadata imageMetadata =
-                (IIOMetadata)pb.getObjectParameter(8);
-
-            // If null, get image metadata from source properties if allowed.
-            if(imageMetadata == null && useProperties) {
-                Object imageMetadataProperty =
-                    source.getProperty(
-                        ImageWriteDescriptor.PROPERTY_NAME_METADATA_IMAGE);
-                if(imageMetadataProperty instanceof IIOMetadata) {
-                    imageMetadata = (IIOMetadata)imageMetadataProperty;
-                }
-            }
-
-            // Transcode the image metadata if requested.
-            if(imageMetadata != null && transcode) {
-                // Overwrite the image metadata with transcoded metadata.
-                imageMetadata = writer.convertImageMetadata(imageMetadata,
-                                                            destinationType,
-                                                            param);
-            }
-
-            // Get the thumbnails if supported by the writer.
-            BufferedImage[] thumbnails = null;
-            if(writer.getNumThumbnailsSupported(destinationType,
-                                                param,
-                                                streamMetadata,
-                                                imageMetadata) > 0) {
-                thumbnails = (BufferedImage[])pb.getObjectParameter(9);
-
-                // If null, get thumbnails from source properties if allowed.
-                if(thumbnails == null && useProperties) {
-                    Object thumbnailsProperty =
-                        source.getProperty(
-                            ImageWriteDescriptor.PROPERTY_NAME_METADATA_IMAGE);
-                    if(thumbnailsProperty instanceof BufferedImage[]) {
-                        thumbnails = (BufferedImage[])thumbnailsProperty;
-                    }
-                }
-            }
-
-            // Get the locale parameter and set on the writer.
-            Locale locale = (Locale)pb.getObjectParameter(11);
-            if(locale != null) {
-                writer.setLocale(locale);
-            }
-
-            // Get the listeners parameter and set on the writer.
-            EventListener[] listeners =
-                (EventListener[])pb.getObjectParameter(10);
-            if(listeners != null) {
-                for(int i = 0; i < listeners.length; i++) {
-                    EventListener listener = listeners[i];
-                    if(listener instanceof IIOWriteProgressListener) {
-                        writer.addIIOWriteProgressListener(
-                            (IIOWriteProgressListener)listener);
-                    }
-                    if(listener instanceof IIOWriteWarningListener) {
-                        writer.addIIOWriteWarningListener(
-                            (IIOWriteWarningListener)listener);
-                    }
-                }
-            }
-
-            // Set the tile size.
-            // XXX Replace ImageWriteParam parameter in ParameterBlock?
-            param = setTileSize(param, writer,
-                                (Dimension)pb.getObjectParameter(6),
-                                source);
-
-            // Create the IIOImage container.
-            IIOImage iioImage = new IIOImage(source,
-                                             thumbnails != null ?
-                                             Arrays.asList(thumbnails) : null,
-                                             imageMetadata);
-
-            try {
-                // Write the image.
-                if(writeToSequence) {
-                    writer.writeToSequence(iioImage, param);
-                } else {
-                    writer.write(streamMetadata, iioImage, param);
-                }
-
-                // Get the pixel replacement parameter.
-                boolean allowPixelReplacement =
-                    ((Boolean)pb.getObjectParameter(5)).booleanValue();
-
-                // Set the return value.
-                if(allowPixelReplacement &&
-                   source instanceof PlanarImage &&
-                   writer.canReplacePixels(imageIndex)) {
-
-                    // Create an image which is a PropertyChangeListener of
-                    // "invalidregion" events including RenderingChangeEvents.
-                    image = new PixelReplacementImage(source,
-                                                      rh,
-                                                      param,
-                                                      writer,
-                                                      imageIndex,
-                                                      streamToClose);
-
-                    // Register the image as a sink of its source so that
-                    // it automatically receives events.
-                    ((PlanarImage)source).addSink(image);
-                } else if(!writeToSequence) {
-                    Object writerOutput = writer.getOutput();
-                    if(writerOutput != pb.getObjectParameter(0) &&
-                       writerOutput instanceof ImageOutputStream) {
-                        // This block is executed if and only if pixel
-                        // replacement is not occurring, a sequence is
-                        // not being written, and an ImageOutputStream
-                        // inaccessible to the application is set on the
-                        // ImageWriter.
-                        ((ImageOutputStream)writerOutput).flush();
-                    }
-
-                    // Set the return value to the original image or
-                    // a wrapped version thereof.
-                    image = source instanceof WritablePropertySource ?
-                        source : new RenderedImageAdapter(source);
-                }
-
-                // Set required properties.
-                WritablePropertySource wps = (WritablePropertySource)image;
-
-                // Set the ImageWriteParam property.
-                wps.setProperty(
-                    ImageWriteDescriptor.PROPERTY_NAME_IMAGE_WRITE_PARAM,
-                    param);
-
-                // Set the ImageWriter property.
-                wps.setProperty(
-                    ImageWriteDescriptor.PROPERTY_NAME_IMAGE_WRITER,
-                    writer);
-
-                // Set the stream metadata property.
-                if(streamMetadata != null) {
-                    wps.setProperty(
-                        ImageWriteDescriptor.PROPERTY_NAME_METADATA_STREAM,
-                        streamMetadata);
-                }
-
-                // Set the image metadata property.
-                if(imageMetadata != null) {
-                    wps.setProperty(
-                        ImageWriteDescriptor.PROPERTY_NAME_METADATA_IMAGE,
-                        imageMetadata);
-                }
-
-                // Set the thumbnail property.
-                if(thumbnails != null) {
-                    wps.setProperty(
-                        ImageWriteDescriptor.PROPERTY_NAME_THUMBNAILS,
-                        thumbnails);
-                }
-            } catch(IOException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        return image;
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/PixelReplacementImage.java zzx2/src/share/classes/com/sun/media/jai/imageioimpl/PixelReplacementImage.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/PixelReplacementImage.java	2005-02-11 00:01:55.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/PixelReplacementImage.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,293 +0,0 @@
-/*
- * $RCSfile: PixelReplacementImage.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:55 $
- * $State: Exp $
- */
-package com.sun.media.jai.imageioimpl;
-
-import java.awt.Point;
-import java.awt.Rectangle;
-import java.awt.Shape;
-import java.awt.image.Raster;
-import java.awt.image.RenderedImage;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Map;
-import java.util.Vector;
-import javax.media.jai.ImageLayout;
-import javax.media.jai.OpImage;
-import javax.media.jai.PlanarImage;
-import javax.media.jai.RenderedOp;
-import javax.media.jai.PropertyChangeEventJAI;
-import javax.media.jai.RenderingChangeEvent;
-import javax.imageio.ImageWriter;
-import javax.imageio.ImageWriteParam;
-import javax.imageio.stream.ImageOutputStream;
-
-/**
- * Implementation of <code>PlanarImage</code> for the "ImageWrite" operation
- * for the case of <code>ImageWriter</code>s which can replace pixels.  The
- * sole purpose of this class is to respond to "invalidregion" events so
- * as to update the written image.
- */
-final class PixelReplacementImage extends PlanarImage
-    implements PropertyChangeListener {
-
-    /**
-     * The <code>ImageWriteParam</code> used in writing the image.
-     */
-    private ImageWriteParam param;
-
-    /**
-     * The <code>ImageWriter</code> used to write the image.
-     */
-    private ImageWriter writer;
-
-    /**
-     * The index of the image to be write.
-     */
-    private int imageIndex;
-
-    /**
-     * A stream to be closed when the instance is disposed; may be null.
-     */
-    private ImageOutputStream streamToClose;
-
-    /**
-     * Creates a <code>Vector</code> containing a single element.
-     */
-    private static Vector createVector(Object element) {
-        Vector v = new Vector(1);
-        v.add(element);
-        return v;
-    }
-
-    /**
-     * XXX
-     */
-    PixelReplacementImage(RenderedImage source,
-                          Map configuration,
-                          ImageWriteParam param,
-                          ImageWriter writer,
-                          int imageIndex,
-                          ImageOutputStream streamToClose) throws IOException {
-        super(new ImageLayout(source),   // Layout same as source.
-              createVector(source),
-              configuration);
-
-        // Verify that the writer can replace pixels.
-        if(!writer.canReplacePixels(imageIndex)) {
-            throw new IllegalArgumentException
-                ("!writer.canReplacePixels(imageIndex)");
-        }
-
-        // Set the instance variables from the parameters.
-        // XXX Should ImageWriteParam original settings be cached for
-        // testing later to see whether anything important has changed?
-        this.param = param;
-        this.writer = writer;
-        this.imageIndex = imageIndex;
-        this.streamToClose = streamToClose;
-    }
-
-    /**
-     * Close an <code>ImageOutputStream</code> passed in.
-     */
-    public void dispose() {
-        if(streamToClose != null) {
-            try {
-                streamToClose.close();
-            } catch(IOException e) {
-                // Ignore it.
-            }
-        }
-
-        super.dispose();
-    }
-
-    /**
-     * Gets a tile.
-     *
-     * @param tileX The X index of the tile.
-     * @param tileY The Y index of the tile.
-     */
-    public Raster getTile(int tileX, int tileY) {
-        return getSourceImage(0).getTile(tileX, tileY);
-    }
-
-    // --- PropertyChangeListener implementation ---
-
-    // XXX Doc
-    public void propertyChange(PropertyChangeEvent evt) {
-        PlanarImage source = getSourceImage(0);
-        Object eventSource = evt.getSource();
-
-        //
-        // Process the event if the writer can replace pixels,
-        // the event source is the source of this OpImage,
-        // and the event name is "invalidregion".
-        //
-        if((evt instanceof PropertyChangeEventJAI &&
-            evt.getPropertyName().equalsIgnoreCase("invalidregion") &&
-            eventSource.equals(source)) ||
-           (evt instanceof RenderingChangeEvent &&
-            evt.getOldValue().equals(source) &&
-            eventSource instanceof RenderedOp &&
-            evt.getNewValue().equals(((RenderedOp)eventSource).getRendering()))) {
-
-            // Get the invalid region information.
-            Shape srcInvalidRegion = null;
-
-            if(evt instanceof RenderingChangeEvent) {
-                // RenderingChangeEvent presumably from a source RenderedOp.
-                RenderingChangeEvent rcEvent = (RenderingChangeEvent)evt;
-
-                // Get the invalidated region of the source.
-                srcInvalidRegion = rcEvent.getInvalidRegion();
-
-                // Reset this image's source.
-                source = (PlanarImage)evt.getNewValue();
-                setSource(source, 0);
-
-                // If entire source is invalid replace with source bounds.
-                if(srcInvalidRegion == null) {
-                    srcInvalidRegion =
-                        ((PlanarImage)rcEvent.getOldValue()).getBounds();
-                }
-            } else {
-                // Get the invalidated region of the source.
-                Object evtNewValue = (Shape)evt.getNewValue();
-
-                // Continue if the value class is correct.
-                if(evtNewValue instanceof Shape) {
-                    srcInvalidRegion = (Shape)evtNewValue;
-
-                    // If entire source is invalid replace with source bounds.
-                    if(srcInvalidRegion == null) {
-                        srcInvalidRegion = source.getBounds();
-                    }
-                }
-            }
-
-            // Return if the invalid portion could not be determined.
-            if(srcInvalidRegion == null) {
-                return;
-            }
-
-            // Return if the invalid region does not overlap the param region.
-            if(param != null) {
-                Rectangle sourceRegion = param.getSourceRegion();
-                if(sourceRegion != null &&
-                   !srcInvalidRegion.intersects(sourceRegion)) {
-                    return;
-                }
-            } else {
-                param = writer.getDefaultWriteParam();
-            }
-
-            // Get indices of all tiles overlapping the invalid region.
-            Point[] tileIndices =
-                source.getTileIndices(srcInvalidRegion.getBounds());
-
-            // Should not happen but return if tileIndices is null.
-            if(tileIndices == null) return;
-
-            // Get subsampling values.
-            int gridX = minX + param.getSubsamplingXOffset();
-            int gridY = minY + param.getSubsamplingYOffset();
-            int stepX = param.getSourceXSubsampling();
-            int stepY = param.getSourceYSubsampling();
-            boolean isSubsampling =
-                stepX != 1 || stepY != 1 || gridX != minX || gridY != minY;
-  
-             // Loop over affected tiles.
-            int numTiles = tileIndices.length;
-            for(int i = 0; i < numTiles; i++) {
-                // Save the next tile index.
-                Point tileIndex = tileIndices[i];
-  
-                 // Compute tile bounds.
-                Rectangle tileRect =
-                    source.getTileRect(tileIndex.x, tileIndex.y);
-  
-                 // Replace if bounds intersect invalid region.
-                if(srcInvalidRegion.intersects(tileRect)) {
-                    // Get the source tile.
-                    Raster raster = source.getTile(tileIndex.x, tileIndex.y);
- 
-                    Rectangle destRect;
-                    if(isSubsampling) {
-                        int destMinX =
-                            (tileRect.x - gridX + stepX - 1)/stepX;
-                        int destMinY =
-                            (tileRect.y - gridY + stepY - 1)/stepY;
-                        int destMaxX =
-                            (tileRect.x + tileRect.width -
-                             gridX + stepX - 1)/stepX;
-                        int destMaxY =
-                            (tileRect.y + tileRect.height -
-                             gridY + stepY - 1)/stepY;
-                        destRect = new Rectangle(destMinX, destMinY,
-                                                 destMaxX - destMinX,
-                                                 destMaxY - destMinY);
-                    } else {
-                        destRect = tileRect;
-                    }
-
-                    // Replace the pixels.
-                    try {
-                        synchronized(writer) {
-                            writer.prepareReplacePixels(imageIndex, destRect);
-                            param.setDestinationOffset(destRect.getLocation());
-                            writer.replacePixels(raster, param);
-                            writer.endReplacePixels();
-                        }
-                    } catch(IOException e) {
-                        throw new RuntimeException(e);
-                    }
-                }
-            }
-        }
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/properties zzx2/src/share/classes/com/sun/media/jai/imageioimpl/properties
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/imageioimpl/properties	2005-02-11 00:01:56.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/imageioimpl/properties	1969-12-31 19:00:00.000000000 -0500
@@ -1,26 +0,0 @@
-#
-# $RCSfile: properties,v $
-#
-# Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.
-#
-# Use is subject to license terms.
-#
-# $Revision: 1.1 $
-# $Date: 2005/02/11 05:01:56 $
-# $State: Exp $
-#
-# Internationalization file for com.sun.media.jai.imageioimpl
-
-ImageReadCRIF0=Cannot create read-only RandomAccessFile for path
-ImageReadCRIF1=Cannot create InputStream for URL
-ImageReadCRIF2=Cannot create InputStream for Socket
-
-ImageReadOpImage0=Destination bounds do not intersect available destination data region.
-ImageReadOpImage1=Source or destination region is empty.
-ImageReadOpImage2=Cannot perform rectangle mapping between source and destination because the image has no sources.
-
-ImageWriteCIF0=Unable to find an ImageWriter for format
-ImageWriteCIF1=Source Collection has more than one image and ImageWriter cannot write sequences.
-
-ImageWriteCRIF0=Cannot create read-write RandomAccessFile for path
-ImageWriteCRIF1=Cannot create OutputStream for Socket
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/I18N.java zzx2/src/share/classes/com/sun/media/jai/operator/I18N.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/I18N.java	2005-02-11 00:01:56.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/operator/I18N.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,54 +0,0 @@
-/*
- * $RCSfile: I18N.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:56 $
- * $State: Exp $
- */
-package com.sun.media.jai.operator;
-
-import com.sun.media.imageioimpl.common.I18NImpl;
-
-final class I18N extends I18NImpl {
-    static String getString(String key) {
-        return getString("com.sun.media.jai.operator.I18N", key);
-    }
-}
-
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/ImageReadDescriptor.java zzx2/src/share/classes/com/sun/media/jai/operator/ImageReadDescriptor.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/ImageReadDescriptor.java	2005-11-30 19:40:32.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/operator/ImageReadDescriptor.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,1100 +0,0 @@
-/*
- * $RCSfile: ImageReadDescriptor.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.2 $
- * $Date: 2005/12/01 00:40:32 $
- * $State: Exp $
- */
-package com.sun.media.jai.operator;
-
-import java.awt.RenderingHints;
-import java.awt.image.RenderedImage;
-import java.awt.image.renderable.ContextualRenderedImageFactory;
-import java.awt.image.renderable.ParameterBlock;
-import java.awt.image.renderable.RenderableImage;
-import java.io.File;
-import java.io.InputStream;
-import java.net.Socket;
-import java.util.Collection;
-import java.util.EventListener;
-import java.util.Locale;
-import javax.imageio.ImageReadParam;
-import javax.imageio.ImageReader;
-import javax.imageio.stream.ImageInputStream;
-import javax.media.jai.JAI;
-import javax.media.jai.OperationDescriptorImpl;
-import javax.media.jai.OperationRegistry;
-import javax.media.jai.PropertyGenerator;
-import javax.media.jai.RenderedOp;
-import javax.media.jai.RenderableOp;
-import javax.media.jai.registry.CollectionRegistryMode;
-import javax.media.jai.registry.RenderableRegistryMode;
-import javax.media.jai.registry.RenderedRegistryMode;
-import com.sun.media.jai.util.PropertyGeneratorImpl;
-
-/**
- * An <code>OperationDescriptor</code> describing the "ImageRead" operation.
- *
- * <p>The "ImageRead" operation uses the
- * <a href="http://java.sun.com/j2se/1.4/docs/guide/imageio/index.html">Java
- * Image I/O Framework</a> to read images from an input source. Which formats
- * may be read depends on which {@link javax.imageio.ImageReader} plug-ins are
- * registered with the Image I/O Framework when the operation is invoked.</p>
- *
- * <p>The input source will usually be an
- * {@link javax.imageio.stream.ImageInputStream}, but may be a
- * {@link java.io.File}, {@link java.io.RandomAccessFile},
- * {@link java.io.InputStream}, {@link java.net.URL},
- * {@link java.net.Socket}, {@link java.nio.channels.ReadableByteChannel},
- * file path represented as a <code>String</code> or some other type
- * compatible with a reader plug-in. The
- * {@link javax.imageio.ImageIO} class should be used to specify the location
- * and enable the use of cache files via its <code>setCacheDirectory()</code>
- * and <code>setUseCache()</code> methods, respectively. Note that this cache
- * pertains to image stream caching and is unrelated to the JAI
- * <code>TileCache</code>.</p>
- *
- * <p>The "ImageRead" operation supports <a href="#RenderedMode">rendered</a>,
- * <a href="#RenderableMode">renderable</a>, and
- * <a href="#CollectionMode">collection</a> modes and requires no source image.
- * A {@link java.awt.RenderingHints} object may be supplied when the operation
- * is created. In addition to the {@link java.awt.RenderingHints.Key} hints
- * recognized by the eventual <code>OpImage</code> constructor, an
- * <a href="#ImageLayout"><code>ImageLayout</code> hint</a> may also be
- * supplied. The settings of this <code>ImageLayout</code> override any other
- * possible derivation of its components. In particular, it is possible that
- * the generated image(s) have a different tile layout than that present in
- * the image read from the input source.</p>
- *
- * <p>Image properties are used to make available metadata and other
- * information. Property provision is mode-specific.</p>
- *
- * <p><table border=1>
- * <caption><b>Resource List</b></caption>
- * <tr><th>Name</th>        <th>Value</th></tr>
- * <tr><td>GlobalName</td>  <td>ImageRead</td></tr>
- * <tr><td>LocalName</td>   <td>ImageRead</td></tr>
- * <tr><td>Vendor</td>      <td>com.sun.media.jai</td></tr>
- * <tr><td>Description</td> <td>Reads an image using the Java Image I/O Framework.</td></tr>
- * <tr><td>DocURL</td>      <td>http://java.sun.com/products/java-media/jai/forDevelopers/jai-imageio-1_0-rc-docs/com/sun/media/jai/operator/ImageReadDescriptor.html</td></tr>
- * <tr><td>Version</td>     <td>1.0</td></tr>
- * <tr><td>arg0Desc</td>    <td>The input source.</td></tr>
- * <tr><td>arg1Desc</td>    <td>The index or indices of the image(s) to read.</td></tr>
- * <tr><td>arg2Desc</td>    <td>Whether metadata should be read if available.</td></tr>
- * <tr><td>arg3Desc</td>    <td>Whether thumbnails should be read if available.</td></tr>
- * <tr><td>arg4Desc</td>    <td>Whether to verify the validity of the input source.</td></tr>
- * <tr><td>arg5Desc</td>    <td>EventListeners to be registered with the ImageReader.</td></tr>
- * <tr><td>arg6Desc</td>    <td>The Locale for the ImageReader to use.</td></tr>
- * <tr><td>arg7Desc</td>    <td>Java Image I/O read parameter instance.</td></tr>
- * <tr><td>arg8Desc</td>    <td>Java Image I/O reader instance.</td></tr>
- * </table></p>
- *
- * <h2><a name="RenderedMode"</a>Rendered Mode</h2>
- *
- * In rendered mode the "ImageRead" operation creates a
- * {@link java.awt.image.RenderedImage} from the specified input source.
- *
- * <h3><a name="RenderedModeParameters"</a>Rendered Mode Parameters</h3>
- *
- * The parameter list of the "ImageRead" operation in rendered mode is
- * as in the following table.
- *
- * <p><table border=1>
- * <caption><b>Rendered Mode Parameter List</b></caption>
- * <tr><th>Name</th>           <th>Class Type</th>
- *                             <th>Default Value</th></tr>
- * <tr><td><a href="#ParamInput">
- *     Input</a></td>          <td>java.lang.Object.class</td>
- *                             <td>NO_PARAMETER_DEFAULT</td>
- * <tr><td><a href="#ParamImageChoice">
- *     ImageChoice</a></td>    <td>java.lang.Integer</td>
- *                             <td>0</td>
- * <tr><td><a href="#ParamReadMetadata">
- *     ReadMetadata</a></td>   <td>java.lang.Boolean</td>
- *                             <td>TRUE</td>
- * <tr><td><a href="#ParamReadThumbnails">
- *     ReadThumbnails</a></td> <td>java.lang.Boolean</td>
- *                             <td>TRUE</td>
- * <tr><td><a href="#ParamVerifyInput">
- *     VerifyInput</a></td>    <td>java.lang.Boolean</td>
- *                             <td>TRUE</td>
- * <tr><td><a href="#ParamListeners">
- *     Listeners</a></td>      <td>java.util.EventListener[]</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamLocale">
- *     Locale</a></td>         <td>java.util.Locale</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamReadParam">
- *     ReadParam</a></td>      <td>javax.imageio.ImageReadParam</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamReader">
- *     Reader</a></td>         <td>javax.imageio.ImageReader</td>
- *                             <td>null</td>
- * </table></p>
- *
- * <p>The rendered mode parameters are handled as follows:
- *
- * <ul>
- * <p><li><a name="ParamInput"</a>
- * If Input is a String it is assumed to represent a file path. When
- *   the node is rendered, if Input is not already an ImageInputStream, then
- *   ImageIO.createImageInputStream() will be used to attempt to derive an
- *   ImageInputStream. If such an ImageInputStream is available, it will be
- *   set as the input of the ImageReader; otherwise the original value of
- *   Input will be used. Before attempting to apply createImageInputStream(),
- *   if Input is a String it will be converted to a RandomAccessFile, or if it
- *   is a Socket or a URL to an InputStream. If the conversion of the Input
- *   String to RandomAccessFile fails, it will be converted to an
- *   InputStream by accessing it as a resource bundled in a JAR file.</li></p>
- * 
- * <p><li><a name="ParamImageChoice"</a>
- * If ImageChoice is negative an exception will be thrown when the
- * operation is created.</li></p>
- * 
- * <p><li><a name="ParamReadMetadata"</a>
- * Image properties associated with metadata will be set if and only if
- *   ReadMetadata is TRUE and the respective metadata are defined. This
- *   parameter overrides the setting of the ignoreMetadata field of the
- *   Reader parameter if the latter is also supplied. Metadata property
- *   values will not be set until requested, i.e., their computation is
- *   deferred.</li></p>
- * 
- * <p><li><a name="ParamReadThumbnails"</a>
- * The image property associated with thumbnails will be set if and only if
- *   ReadThumbnails is TRUE and thumbnails are defined for the image at the
- *   specified index. Thumbnail property values are not set until requested,
- *   i.e., their computation is deferred.</li></p>
- * 
- * <p><li><a name="ParamVerifyInput"</a>
- * If VerifyInput is TRUE and Input is either a File or a String which
- *   specifies a file path, then canRead() will be invoked on Input or a
- *   derived File object as appropriate. If canRead() returns 'false' an
- *   exception will be thrown. Note that the canRead() method can not be
- *   invoked in the case of the Input being a String specifying a file path
- *   which can be accessed only as an InputStream resource from a JAR file.
- *   This option is useful to suppress verifying
- *   the existence of a file on the local file system when this operation is
- *   created as the local portion of a remote operation which will be
- *   rendered on a remote peer. This verification will occur when the
- *   operation is created. </li></p>
- * 
- * <p><li>If VerifyInput is TRUE and Input is a Socket, then an exception will
- *   be thrown if the socket is not bound, not connected, is closed, or its
- *   read-half is shut down. This verification will occur when the
- *   operation is created.</li></p>
- * 
- * <p><li><a name="ParamListeners"</a>
- * Listeners will be used to set any progress, update, or warning listeners
- * of the ImageReader. Each element in the java.util.EventListener array will
- * be added for all types of listener it implements. For example if a listener
- *   object implements all of the javax.imageio.event.IIORead*Listeners
- *   interfaces then it will be added as a listener of each of the three types.
- *   Any elements in the array which do not implement any of the
- * IIORead*Listeners will be ignored.</li></p>
- * 
- * <p><li><a name="ParamLocale"</a>
- * Locale will be used to set the Locale of the ImageReader. This parameter
- *   overrides the equivalent setting of the Reader parameter if the latter is
- *   also supplied.</li></p>
- * 
- * <p><li><a name="ParamReadParam"</a>
- * If ReadParam is null, an ImageReadParam will be derived internally using
- * ImageReader.getDefaultReadParam(). Supplying an ImageReadParam can be
- * useful for special operations such as setting the bands to read via
- * setSourceBands() or the subsampling factors via
- * setSourceSubsampling(). If the ImageReadParam parameter is not an instance
- * of a cloneable subclass of javax.imageio.ImageReadParam, then it would be
- * best to avoid using the setDestinationType(), setDestinationOffset(), and
- * setSourceRegion() methods on the supplied object as these methods will be
- * invoked internally by the reader.</li></p>
- * 
- * <p><li><a name="ParamReader"</a>
- * If Reader is null, an attempt will be made to derive an ImageReader
- *   using ImageIO.getImageReaders().</li></p>
- * </ul></p>
- *
- * <h4><a name="SyncPolicy"</a>Parameters and Synchronization Policy</h4>
- *
- * Note that any supplied ImageReadParam parameter may be modified within this
- * operator. Also, any of the various reading methods of the ImageReader may be
- * invoked at an arbitrary subsequent time to populate the image data. Correct
- * handling of these parameters at the application level is left to the user.
- * Specifically no guarantee as to the correct behavior of this operation is
- * made in the cases wherein a user passes in an ImageReadParam or ImageReader
- * parameter and modifies its state while this operation is still using these
- * objects. This applies especially in the case of multi-threaded applications.
- * In such instances it is recommended that the user either not pass in either
- * of these parameters or simply use the Java Image I/O API directly rather
- * than the JAI operation. (Threads managed internally by JAI, e.g., in the
- * TileScheduler, interact with the image object created by this operation only
- * via synchronized methods thereby preventing potential race conditions.)
- * These caveats also apply to the use of ImageReaders and ImageReadParams
- * obtained from image properties.
- * 
- * <p>The foregoing policy regarding modification of any supplied ImageReadParam
- * or ImageReader is necessary as neither of these classes is cloneable. Given
- * that as a starting point there are in effect three possibilities: (A) do not
- * accept them as parameters, (B) accept them via alternate parameters which do
- * not pose these problems (for example an ImageReaderSpi and a long list of
- * settings represented by the ImageReadParam), or (C) accept them explicitly.
- * Option C has been deemed preferable despite the potential race condition
- * issues.</p>
- * 
- * <p>In the Sun Microsystems implementation of this operation these potential
- * conflicts have been mitigated to a certain extent:
- *
- * <ul>
- * <p><li>If the param is cloneable then it is cloned and the clone used internally.
- *   Otherwise if the param is an instance of ImageReadParam itself rather than
- *   of a subclass thereof, i.e., getClass().getName() invoked on the param
- *   returns "javax.imageio.ImageReadParam", then a new ImageReadParam is
- *   constructed and the settings of the original param copied to it. If the
- *   param is not cloneable and is an instance of a proper subclass of
- *   ImageWriteParam then it is used directly.</li></p>
- * 
- * <p><li>The only ImageReader methods invoked after OpImage construction are
- *   read(int,ImageReadParam), getNumThumbnails(int), readThumbnail(int,int),
- *   isIgnoringMetadata(), getStreamMetadata(), and getImageMetadata(int).
- *   These methods are invoked within getProperty() and with the exception
- *   of isIgnoringMetadata() are synchronized on the ImageReader.</li></p>
- * </ul>
- * </p>
- *
- * <h3><a name="ImageLayout"</a>ImageLayout Hint Handling</h3>
- *
- * If an ImageLayout hint is provided via the operation's RenderingHints, its
- * values will be used. In particular a SampleModel or ColorModel supplied via
- * an ImageLayout hint will override any values set via the ImageTypeSpecifier
- * of the ImageReadParam parameter if the latter is non-null. This signifies
- * that the ImageTypeSpecifier of the OpImage rendering associated with the
- * operation node will be forced to match that of the layout even if this type
- * is different from or incompatible with the image types available from the
- * ImageReader. Note that in such an eventuality an extra amount of memory
- * equal to one image tile might be needed for copying purposes. This copying
- * is handled by the JAI operation itself.
- * 
- * <p>Any fields of the supplied ImageLayout which are not set will be set to
- * default values as follows. The ImageLayout will be cloned before it is
- * modified.</p>
- *
- * <h4>ImageLayout Defaults</h4>
- *
- * <p><ul>
- * <p><li>Image Bounds {minX, minY, width, height}
- * 
- * <p>Each value defaults to the corresponding value of the destination
- * which would be derived on the basis of the source image dimensions
- * and the settings of the ImageReadParam, i.e., source region,
- * subsampling offsets and factors, and destination offset.</p>
- * 
- * <p>It should be noted that unlike in the Java Image I/O API itself,
- * negative coordinates are permitted and the image origin is not
- * required to be at (0,0) as for BufferedImages. Therefore it is
- * possible that a given image be loaded using the same ImageReadParam
- * by an ImageReader and by the "ImageRead" operation with different
- * results. Possible differences would be that the portion of the
- * image with negative coordinates is not clipped as it would be with
- * direct Image I/O access, and no empty extent between (0,0) and the
- * start of the data will be present.</p>
- * 
- * <p>For example, if the ImageReadParam had sourceRegion [0,0,w,h],
- * destinationOffset [-w/2,-h/2], and no subsampling, then the Java
- * Image I/O API would compute the effective source and destination
- * regions to be [w/2,h/2,w/2,h/2] and [0,0,w/2,h/2], respectively.
- * The JAI ImageRead operation would compute the effective source and
- * destination regions to be [0,0,w,h] and [-w/2,-h/2,w,h], respectively.
- * The Image I/O result would therefore be equal to the bottom right
- * quadrant of the JAI result.</p></li></p>
- * 
- * <p><li>Tile Grid {tileGridXOffset, tileGridYOffset, tileWidth, tileHeight}
- *
- * <pre>
- * tileGridXOffset = ImageReader.getTileGridXOffset(imageIndex);
- * tileGridYOffset = ImageReader.getTileGridYOffset(imageIndex);
- * tileWidth = ImageReader.getTileWidth(imageIndex);
- * tileHeight = ImageReader.getTileHeight(imageIndex);
- * </pre></li></p>
- * 
- * <p><li>ColorModel
- * 
- * <pre>
- * ImageReader.getRawImageType(imageIndex).getColorModel();
- * </pre></li></p>
- * 
- * <p><li>SampleModel
- * 
- * <pre>
- * ImageReader.getRawImageType(imageIndex).getSampleModel().createCompatibleSampleModel(tileWidth, tileHeight);
- * </pre></li></p>
- * </ul></p>
- *
- * <h3><a name="RenderedModeProperties"</a>Image Properties in Rendered Mode</h3>
- *
- * Image properties are used to provide metadata, thumbnails, and reader-related
- * information. The following properties may be obtained from the RenderedOp
- * created for the "ImageRead" operation in rendered mode:
- *
- * <p><table border=1>
- * <caption><b>Rendered Mode Image Properties</b></caption>
- * <tr>
- * <th>Property Name</th>
- * <th>Type</th>
- * <th>Comment</th>
- * </tr>
- * <tr>
- * <td>JAI.ImageReadParam</td>
- * <td>ImageReadParam</td>
- * <td>Set to ImageReadParam actually used which may differ from the one passed in.</td>
- * </tr>
- * <tr>
- * <td>JAI.ImageReader</td>
- * <td>ImageReader</td>
- * <td>Set to ImageReader actually used.</td>
- * </tr>
- * <tr>
- * <td>JAI.ImageMetadata</td>
- * <td>IIOMetadata</td>
- * <td>Set if and only if ReadMetadata parameter is TRUE and image metadata are available.</td>
- * </tr>
- * <tr>
- * <td>JAI.StreamMetadata</td>
- * <td>IIOMetadata</td>
- * <td>Set if and only if ReadMetadata parameter is TRUE and stream metadata are available.</td>
- * </tr>
- * <tr>
- * <td>JAI.Thumbnails</td>
- * <td>BufferedImage[]</td>
- * <td>Set if and only if ReadThumbnails parameter is TRUE and thumbnails are available.</td>
- * </tr>
- * </table></p>
- * 
- * <p>If a given property is not set, this implies of course that the names of
- * absent properties will not appear in the array returned by getPropertyNames()
- * and getProperty() invoked to obtain absent properties will return
- * java.awt.Image.UndefinedProperty as usual.</p>
- * 
- * <p>The ImageReader and ImageReadParam may be used for subsequent invocations
- * of the operation (for example to obtain different images in a multi-page file)
- * or for informational purposes. Care should be taken in using these property
- * values with respect to the synchronization issues previously discussed.</p>
- * 
- * <p>In all cases image metadata properties will be set when the node is rendered,
- * i.e., metadata reading is not subject to the same deferred execution as is
- * image data reading. The thumbnail property value will not be set however until
- * its value is actually requested.</p>
- *
- * <h2><a name="RenderableMode"</a>Renderable Mode</h2>
- *
- * In renderable mode the "ImageRead" operation creates a
- * {@link java.awt.image.renderable.RenderableImage} from the specified
- * input source.
- *
- * <p>It should be noted that although they are discussed in the context of
- * rendered mode, the <a href="#SyncPolicy">parameter synchronization
- * policy</a> and <a href="#ImageLayout">ImageLayout handling methodology</a>
- * apply to renderable mode as well.</p>
- *
- * <h3><a name="RenderableModeParameters"</a>Renderable Mode Parameters</h3>
- *
- * The parameter list of the "ImageRead" operation in renderable mode is
- * identical to the <a href="#RenderedModeParameters">rendered mode parameter
- * list</a> mode except as indicated in the following table.
- *
- * <p><table border=1>
- * <caption><b>Renderable Mode Parameter Differences</b></caption>
- * <tr><th>Name</th>           <th>Class Type</th>
- *                             <th>Default Value</th></tr>
- * <tr><td>ImageChoice</td>    <td>int[]</td>
- *                             <td>int[] {0,...,NumImages-1}</td>
- * </table></p>
- *
- * <p>In the Sun Microsystems renderable mode implementation of the "ImageRead"
- * operation, when createRendering() is invoked on the RenderableImage created
- * by the operation, a MultiResolutionRenderableImage is constructed from a
- * Vector of RenderedImages consisting of the images at the specified indices.
- * These images will be sorted into order of decreasing resolution (as
- * determined by the product of width and height for each image) and inserted
- * in this order in the Vector of images used to construct the
- * MultiResolutionRenderableImage. Metadata will be set on the component
- * RenderedImages as usual for rendered mode. Finally the
- * createRendering() invocation will be forwarded to the underlying
- * MultiResolutionRenderableImage and the resulting RenderedImage returned.</p>
- *
- * <p>Note that using this approach the entire MultiResolutionRenderableImage
- * must be regenerated for each invocation of createRendering(). If multiple
- * renderings are to be created from the RenderableImage without changing
- * the operation parameters, then a more efficient approach would be to use the
- * "JAI.RenderableInput" property to be described.</p>
- *
- * <h3>Image Properties in Renderable Mode</h3>
- *
- * The following property will be set on the RenderableOp created for the
- * "ImageRead" operation in renderable mode:
- *
- * <p><table border=1>
- * <caption><b>Renderable Mode Image Properties</b></caption>
- * <tr>
- * <th>Property Name</th>
- * <th>Type</th>
- * <th>Comment</th>
- * </tr>
- * <tr>
- * <td>JAI.RenderableInput</td>
- * <td>RenderableImage</td>
- * <td>A RenderableImage derived from the input source according to the supplied set of parameters.</td>
- * </tr>
- * </table></p>
- * 
- * <p>The RenderableImage which is the value of the foregoing property may have
- * set on it any of the properties previously described for rendered mode
- * contingent on parameter settings and data availability. The image metadata
- * and thumbnail properties would be copied from the highest resolution image
- * among those specified by the ImageChoice parameter.</p>
- * 
- * <p>If multiple renderings are to be created from the RenderableImage
- * without changing the operation parameters, then an efficient alternative
- * approach to multiple invocations of createRendering() on the RenderableImage
- * is to obtain the RenderableImage value of the "JAI.RenderableInput" property
- * and invoke createRendering() on this value.</p>
- *
- * <h2><a name="CollectionMode"</a>Collection Mode</h2>
- *
- * In collection mode the "ImageRead" operation creates a
- * <code>Collection</code> of <code>RenderedImage</code>s from the specified
- * input source. This could be used for example to load an animated GIF
- * image or a multi-page TIFF image.
- *
- * <p>It should be noted that although they are discussed in the context of
- * rendered mode, the <a href="#SyncPolicy">parameter synchronization
- * policy</a> and <a href="#ImageLayout">ImageLayout handling methodology</a>
- * apply to collection mode as well.</p>
- *
- * <h3>Collection Mode Parameters</h3>
- *
- * The parameter list of the "ImageRead" operation in collection mode is
- * identical to the <a href="#RenderableModeParameters">renderable mode
- * parameter list</a>. In this case
- * the RenderedImages loaded for the specified indices will be used to create
- * a Collection of RenderedImages. The images will be loaded in the order of
- * the indices in the supplied array and appended to a List. The rendering of
- * the operation will be a CollectionImage the 'imageCollection' instance
- * variable of which will be set to this List.
- *
- * <h3>Image Properties in Collection Mode</h3>
- *
- * Contingent on parameter settings and the presence of the appropriate
- * metadata, the rendered Collection may have the "JAI.StreamMetadata",
- * "JAI.ImageReadParam", and "JAI.ImageReader" properties set. Each
- * RenderedImage in the Collection may contain the
- * <a href="#RenderedModeProperties">rendered mode properties</a> contingent
- * on parameter settings and data availability.
- *
- * @see javax.media.jai.OperationDescriptor
- * @see javax.imageio.ImageReader
- * @see javax.imageio.ImageReadParam
- * @see javax.imageio.metadata.IIOMetadata
- * @see javax.imageio.stream.ImageInputStream
- */
-public class ImageReadDescriptor extends OperationDescriptorImpl {
-
-    // Property name constants have package access for image factory use.
-
-    /** ImageReadParam property name "JAI.ImageReadParam". */
-    public static final String PROPERTY_NAME_IMAGE_READ_PARAM =
-        "JAI.ImageReadParam";
-
-    /** ImageReader property name "JAI.ImageReader". */
-    public static final String PROPERTY_NAME_IMAGE_READER =
-        "JAI.ImageReader";
-
-    /** Image metadata property name "JAI.ImageMetadata". */
-    public static final String PROPERTY_NAME_METADATA_IMAGE =
-        "JAI.ImageMetadata";
-
-    /** Stream metadata property name "JAI.StreamMetadata". */
-    public static final String PROPERTY_NAME_METADATA_STREAM =
-        "JAI.StreamMetadata";
-
-    /** Thumbnail property name "JAI.Thumbnails". */
-    public static final String PROPERTY_NAME_THUMBNAILS =
-        "JAI.Thumbnails";
-
-    /**
-     * Renderable input property name "JAI.RenderableInput".
-     */
-    public static final String PROPERTY_NAME_RENDERABLE_INPUT =
-        "JAI.RenderableInput";
-
-    /**
-     * Test method.
-     *
-     * @param args {inputFile[, mode]}
-     * @throws Throwable any error.
-     */
-    /* XXX
-    public static void main(String[] args) {
-        String fileName = args[0];
-        String modeName = args.length > 1 ?
-            args[1] : RenderedRegistryMode.MODE_NAME;
-
-        ParameterBlock pb =
-            (new ParameterBlock()).add(new java.io.File(fileName));
-
-        java.awt.image.RenderedImage[] images = null;
-        if(modeName.equalsIgnoreCase(RenderedRegistryMode.MODE_NAME)) {
-            images = new java.awt.image.RenderedImage[1];
-            images[0] = JAI.create("ImageRead", pb, null);
-            PrintProps.print((javax.media.jai.PropertySource)images[0]);
-        } else if(modeName.equalsIgnoreCase(RenderableRegistryMode.MODE_NAME)) {
-            //pb.add(new int[] {0});
-            java.awt.image.renderable.RenderableImage ri =
-                JAI.createRenderable("ImageRead", pb, null);
-            PrintProps.print((javax.media.jai.PropertySource)ri);
-            images = new java.awt.image.RenderedImage[1];
-            //java.awt.image.renderable.RenderContext rc =
-            //    new java.awt.image.renderable.RenderContext(
-            //        new java.awt.geom.AffineTransform(42, 0, 0, 42, 0, 0));
-            //images[0] = ri.createRendering(rc);
-            images[0] = ri.createDefaultRendering();
-            PrintProps.print((javax.media.jai.PropertySource)images[0]);
-        } else if(modeName.equalsIgnoreCase(CollectionRegistryMode.MODE_NAME)) {
-            //pb.add(new int[] {0});
-            java.util.Collection imageCollection =
-                JAI.createCollection("ImageRead", pb, null);
-            PrintProps.print((javax.media.jai.PropertySource)imageCollection);
-            images = new java.awt.image.RenderedImage[imageCollection.size()];
-            imageCollection.toArray(images);
-        } else {
-            throw new UnsupportedOperationException(modeName+" mode not supported");
-        }
-
-        final java.awt.Frame frame = new java.awt.Frame();
-        frame.addWindowListener(new java.awt.event.WindowAdapter() {
-                public void windowClosing(java.awt.event.WindowEvent e) {
-                    frame.setEnabled(false);
-                    frame.dispose();
-                }
-            });
-
-        int gridSide = (int)(Math.sqrt(images.length) + 0.5);
-        frame.setLayout(new java.awt.GridLayout(gridSide, gridSide));
-        java.awt.Dimension screenSize =
-            java.awt.Toolkit.getDefaultToolkit().getScreenSize();
-        int width =
-            Math.min(screenSize.width/gridSide, images[0].getWidth());
-        int height =
-            Math.min(screenSize.height/gridSide, images[0].getHeight());
-        for(int i = 0; i < images.length; i++) {
-            javax.media.jai.widget.ScrollingImagePanel panel =
-                new javax.media.jai.widget.ScrollingImagePanel(images[i],
-                                                               width, //image.getWidth(),
-                                                               height);//image.getHeight());
-            frame.add(panel);
-        }
-        frame.pack();
-        frame.show();
-    }
-    */
-
-    /**
-     * The name of the operation.
-     */
-    private static final String OPERATION_NAME = "ImageRead";
-
-    /**
-     * The resource strings that provide the general documentation and
-     * specify the parameter list for the "ImageRead" operation.
-     */
-    private static final String[][] resources = {
-        {"GlobalName",  OPERATION_NAME},
-        {"LocalName",   OPERATION_NAME},
-        {"Vendor",      "com.sun.media.jai"},
-        {"Description", I18N.getString("ImageReadDescriptor0")},
-        {"DocURL",      "http://java.sun.com/products/java-media/jai/forDevelopers/jai-apidocs/javax/media/jai/operator/ImageReadDescriptor.html"},
-        {"Version",     I18N.getString("DescriptorVersion")},
-        {"arg0Desc",    I18N.getString("ImageReadDescriptor1")},
-        {"arg1Desc",    I18N.getString("ImageReadDescriptor2")},
-        {"arg2Desc",    I18N.getString("ImageReadDescriptor3")},
-        {"arg3Desc",    I18N.getString("ImageReadDescriptor4")},
-        {"arg4Desc",    I18N.getString("ImageReadDescriptor5")},
-        {"arg5Desc",    I18N.getString("ImageReadDescriptor6")},
-        {"arg6Desc",    I18N.getString("ImageReadDescriptor7")},
-        {"arg7Desc",    I18N.getString("ImageReadDescriptor8")},
-	{"arg8Desc",    I18N.getString("ImageReadDescriptor9")}
-    };
-
-    /** The parameter names for the "ImageRead" operation. */
-    private static final String[] paramNames = {
-        "Input", "ImageChoice", "ReadMetadata", "ReadThumbnails",
-        "VerifyInput", "Listeners", "Locale", "ReadParam", "Reader"
-    };
-
-    /** The parameter class types for rendered mode of "ImageRead". */
-    private static final Class[] renderedParamClasses = {
-        java.lang.Object.class,             // Input
-        java.lang.Integer.class,            // ImageChoice
-	java.lang.Boolean.class,            // ReadMetadata
-	java.lang.Boolean.class,            // ReadThumbnails
-	java.lang.Boolean.class,            // VerifyInput
-        java.util.EventListener[].class,    // Listeners
-        java.util.Locale.class,             // Locale
-	javax.imageio.ImageReadParam.class, // ReadParam
-	javax.imageio.ImageReader.class     // Reader
-    };
-
-    /** The parameter default values for rendered mode of "ImageRead". */
-    private static final Object[] renderedParamDefaults = {
-        NO_PARAMETER_DEFAULT, // Input
-        new Integer(0),       // ImageChoice
-        Boolean.TRUE,         // ReadMetadata
-        Boolean.TRUE,         // ReadThumbnails
-        Boolean.TRUE,         // VerifyInput
-        null,                 // Listeners
-        null,                 // Locale
-        null,                 // ReadParam
-        null                  // Reader
-    };
-
-    /** The parameter class types for renderable mode of "ImageRead". */
-    private static final Class[] renderableParamClasses = {
-        java.lang.Object.class,             // Input
-        int[].class,                        // ImageChoice
-	java.lang.Boolean.class,            // ReadMetadata
-	java.lang.Boolean.class,            // ReadThumbnails
-	java.lang.Boolean.class,            // VerifyInput
-        java.util.EventListener[].class,    // Listeners
-        java.util.Locale.class,             // Locale
-	javax.imageio.ImageReadParam.class, // ReadParam
-	javax.imageio.ImageReader.class     // Reader
-    };
-
-    /** The parameter default values for renderable mode of "ImageRead". */
-    private static final Object[] renderableParamDefaults = {
-        NO_PARAMETER_DEFAULT, // Input
-        null,                 // ImageChoice
-        Boolean.TRUE,         // ReadMetadata
-        Boolean.TRUE,         // ReadThumbnails
-        Boolean.TRUE,         // VerifyInput
-        null,                 // Listeners
-        null,                 // Locale
-        null,                 // ReadParam
-        null                  // Reader
-    };
-
-    /** The parameter class types for collection mode of "ImageRead". */
-    private static final Class[] collectionParamClasses =
-        renderableParamClasses;
-
-    /** The parameter default values for collection mode of "ImageRead". */
-    private static final Object[] collectionParamDefaults =
-        renderableParamDefaults;
-
-    /** Constructor. */
-    public ImageReadDescriptor() {
-        super(resources,
-              new String[] {RenderedRegistryMode.MODE_NAME,
-                            RenderableRegistryMode.MODE_NAME,
-                            CollectionRegistryMode.MODE_NAME},
-              null, // sourceNames
-              new Class[][] {null, null, null}, // sourceClasses
-              paramNames,
-              new Class[][] {renderedParamClasses,
-                             renderableParamClasses,
-                             collectionParamClasses},
-              new Object[][] {renderedParamDefaults,
-                              renderableParamDefaults,
-                              collectionParamDefaults},
-              new Object[][] {null, null, null}); // validParamValues
-    }
-
-    /**
-     * Type-safe convenience method for creating a {@link RenderedOp}
-     * representing the "ImageRead" operation in rendered mode. The
-     * method packs the parameters into a new <code>ParameterBlock</code>
-     * and invokes {@link JAI#create(String,ParameterBlock,RenderingHints)}.
-     *
-     * @param input The input source.
-     * @param imageChoice The index of the image to read.
-     * @param readMetadata Whether metadata should be read if available.
-     * @param readThumbnails Whether thumbnails should be read if available.
-     * @param verifyInput Whether to verify the validity of the input source.
-     * @param listeners EventListeners to be registered with the ImageReader.
-     * @param locale The Locale for the ImageReader to use.
-     * @param readParam Java Image I/O read parameter instance.
-     * @param reader Java Image I/O reader instance.
-     * @param hints Hints possibly including an <code>ImageLayout</code>.
-     * @return an image derived from the input source.
-     */
-    public static RenderedOp create(ImageInputStream input,
-                                    Integer imageChoice,
-                                    Boolean readMetadata,
-                                    Boolean readThumbnails,
-                                    Boolean verifyInput,
-                                    EventListener[] listeners,
-                                    Locale locale,
-                                    ImageReadParam readParam,
-                                    ImageReader reader,
-                                    RenderingHints hints) {
-
-        ParameterBlock args = new ParameterBlock();
-
-        args.add(input);
-        args.add(imageChoice);
-        args.add(readMetadata);
-        args.add(readThumbnails);
-        args.add(verifyInput);
-        args.add(listeners);
-        args.add(locale);
-        args.add(readParam);
-        args.add(reader);
-
-        return JAI.create(OPERATION_NAME, args, hints);
-    }
-
-    /**
-     * Type-safe convenience method for creating a {@link Collection}
-     * representing the "ImageRead" operation in collection mode. The
-     * method packs the parameters into a new <code>ParameterBlock</code>
-     * and invokes
-     * {@link JAI#createCollection(String,ParameterBlock, RenderingHints)}.
-     *
-     * @param input The input source.
-     * @param imageChoice The indices of the images to read.
-     * @param readMetadata Whether metadata should be read if available.
-     * @param readThumbnails Whether thumbnails should be read if available.
-     * @param verifyInput Whether to verify the validity of the input source.
-     * @param listeners EventListeners to be registered with the ImageReader.
-     * @param locale The Locale for the ImageReader to use.
-     * @param readParam Java Image I/O read parameter instance.
-     * @param reader Java Image I/O reader instance.
-     * @param hints Hints possibly including an <code>ImageLayout</code>.
-     * @return a collection of images derived from the input source.
-     */
-    public static Collection createCollection(ImageInputStream input,
-                                              int[] imageChoice,
-                                              Boolean readMetadata,
-                                              Boolean readThumbnails,
-                                              Boolean verifyInput,
-                                              EventListener[] listeners,
-                                              Locale locale,
-                                              ImageReadParam readParam,
-                                              ImageReader reader,
-                                              RenderingHints hints) {
-
-        ParameterBlock args = new ParameterBlock();
-
-        args.add(input);
-        args.add(imageChoice);
-        args.add(readMetadata);
-        args.add(readThumbnails);
-        args.add(verifyInput);
-        args.add(listeners);
-        args.add(locale);
-        args.add(readParam);
-        args.add(reader);
-
-        return JAI.createCollection(OPERATION_NAME, args, hints);
-    }
-
-    /**
-     * Type-safe convenience method for creating a {@link RenderableOp}
-     * representing the "ImageRead" operation in renderable mode. The
-     * method packs the parameters into a new <code>ParameterBlock</code>
-     * and invokes
-     * {@link JAI#createRenderable(String,ParameterBlock,RenderingHints)}.
-     *
-     * @param input The input source.
-     * @param imageChoice The indices of the images to read.
-     * @param readMetadata Whether metadata should be read if available.
-     * @param readThumbnails Whether thumbnails should be read if available.
-     * @param verifyInput Whether to verify the validity of the input source.
-     * @param listeners EventListeners to be registered with the ImageReader.
-     * @param locale The Locale for the ImageReader to use.
-     * @param readParam Java Image I/O read parameter instance.
-     * @param reader Java Image I/O reader instance.
-     * @param hints Hints possibly including an <code>ImageLayout</code>.
-     * @return an image capable of rendering an image from those in the
-     * input source.
-     */
-    public static RenderableOp createRenderable(ImageInputStream input,
-                                                int[] imageChoice,
-                                                Boolean readMetadata,
-                                                Boolean readThumbnails,
-                                                Boolean verifyInput,
-                                                EventListener[] listeners,
-                                                Locale locale,
-                                                ImageReadParam readParam,
-                                                ImageReader reader,
-                                                RenderingHints hints) {
-
-        ParameterBlock args = new ParameterBlock();
-
-        args.add(input);
-        args.add(imageChoice);
-        args.add(readMetadata);
-        args.add(readThumbnails);
-        args.add(verifyInput);
-        args.add(listeners);
-        args.add(locale);
-        args.add(readParam);
-        args.add(reader);
-
-        return JAI.createRenderable(OPERATION_NAME, args, hints);
-    }
-
-    /**
-     * Returns the array of {@link PropertyGenerator}s for the specified
-     * mode of this operation.
-     *
-     * <p>For renderable mode returns an array containing a single
-     * <code>PropertyGenerator</code> which defines a
-     * {@link RenderableImage}-valued property named "JAI.RenderableInput".
-     * For all other modes <code>null</code> is returned.</p>
-     *
-     * @param modeName The name of the mode.
-     * @return An array containing a single <code>PropertyGenerator</code>
-     * if <code>modeName</code> is "renderable" (case-insensitive) or
-     * <code>null</code> otherwise.
-     */
-    public PropertyGenerator[] getPropertyGenerators(String modeName) {
-        return modeName.equalsIgnoreCase(RenderableRegistryMode.MODE_NAME) ?
-            new PropertyGenerator[] { new ImageReadPropertyGenerator() } :
-            null;
-    }
-
-    /**
-     * Validates the parameters in the supplied <code>ParameterBlock</code>.
-     *
-     * <p>In addition to the standard validation performed by the
-     * corresponding superclass method, this method verifies the following:
-     * <ul>
-     * <li>whether <i>ImageChoice</i> is negative (rendered mode)
-     * or contains any negative indices (other modes); and</li>
-     * <li>if <i>VerifyInput</i> is <code>TRUE</code> and <i>Input</i>
-     * is a <code>File</code> or <code>String</code>, whether the
-     * corresponding physical file exists and is readable; and</li>
-     * <li>if <i>VerifyInput</i> is <code>TRUE</code> and <i>Input</i>
-     * is a <code>String</code>, converting which to a 
-     * corresponding physical file failed, whether it can be converted
-     * to an InputStream accessed as a resource from a JAR file; and</li>
-     * <li>if <i>VerifyInput</i> is <code>TRUE</code> and <i>Input</i>
-     * is a <code>Socket</code>, whether it is bound, connected, open,
-     * and the read-half is not shut down.</li>
-     * </ul>
-     *
-     * If the superclass method finds that the arguments are invalid, or if
-     * this method determines that any of the foregoing conditions is true,
-     * an error message will be appended to <code>msg</code> and
-     * <code>false</code> will be returned; otherwise <code>true</code> will
-     * be returned.</p>
-     *
-     * <p>The file existence and readability verification may be suppressed
-     * by setting the <i>VerifyInput</i> parameter to <code>FALSE</code>.
-     * This might be desirable for example if the operation is being
-     * created for remote rendering and <i>Input</i> is a file which is at
-     * a location visible on the remote peer but not on the host on which
-     * the operation is created.</p>
-     *
-     * @param modeName The operation mode.
-     * @param args The source and parameters of the operation.
-     * @param msg A container for any error messages.
-     *
-     * @return Whether the supplied parameters are valid.
-     */
-    protected boolean validateParameters(String modeName,
-                                         ParameterBlock args,
-                                         StringBuffer msg) {
-        if (!super.validateParameters(modeName, args, msg)) {
-            return false;
-        }
-
-        // Check "ImageChoice" for negative value(s).
-        if(modeName.equalsIgnoreCase(RenderedRegistryMode.MODE_NAME)) {
-            if(args.getIntParameter(1) < 0) {
-                msg.append(I18N.getString("ImageReadDescriptor10"));
-                return false;
-            }
-        } else { // Non-rendered modes.
-            int[] imageIndices = (int[])args.getObjectParameter(1);
-            if(imageIndices != null) {
-                for(int i = 0; i < imageIndices.length; i++) {
-                    if(imageIndices[i] < 0) {
-                        msg.append(I18N.getString("ImageReadDescriptor10"));
-                        return false;
-                    }
-                }
-            }
-        }
-
-        // Check the input if so requested by "VerifyInput".
-	Boolean verifyInput = (Boolean)args.getObjectParameter(4);
-	if (verifyInput.booleanValue()){
-            // Get the Input parameter.
-            Object input = args.getObjectParameter(0);
-
-            if(input instanceof File || input instanceof String) {
-                // Set file and path variables.
-                File file = null;
-                String path = null;
-                if(input instanceof File) {
-                    file = (File)input;
-                    path = file.getPath();
-                } else if(input instanceof String) {
-                    path = (String)input;
-                    file = new File(path);
-                }
-
-                // If input is a verify that it exists and is readable.
-                if(file != null) {
-                    if (!file.exists()) {
-			// Check if the file is accessible as an InputStream
-			// resource. This would be the case if the application
-			// and the image file are packaged in a JAR file
-			InputStream is = 
-			    getClass().getClassLoader().getResourceAsStream((String)input);
-			if(is == null) {
-			    msg.append("\"" + path + "\": " + 
-				       I18N.getString("ImageReadDescriptor11"));
-			    return false;
-			}
-                    } else if (!file.canRead()) {
-                        msg.append("\"" + path + "\": " + 
-                                   I18N.getString("ImageReadDescriptor12"));
-                        return false;
-                    }
-                }
-            } else if(input instanceof Socket) {
-                Socket socket = (Socket)input;
-
-                if(socket.isInputShutdown()) {
-                    msg.append("\"" + socket + "\": " + 
-                               I18N.getString("ImageReadDescriptor13"));
-                    return false;
-                } else if(socket.isClosed()) {
-                    msg.append("\"" + socket + "\": " + 
-                               I18N.getString("ImageReadDescriptor14"));
-                    return false;
-                } else if(!socket.isBound()) {
-                    msg.append("\"" + socket + "\": " + 
-                               I18N.getString("ImageReadDescriptor15"));
-                    return false;
-                } else if(!socket.isConnected()) {
-                    msg.append("\"" + socket + "\": " + 
-                               I18N.getString("ImageReadDescriptor16"));
-                    return false;
-                }
-            }
-        }
-        
-        return true;
-    }
-}
-
-// XXX Does this need to return ImageReader and ReadParam props also?
-// XXX This same property needs to be set also on each rendering so that
-// copying does not occur and require more computation.
-final class ImageReadPropertyGenerator extends PropertyGeneratorImpl {
-
-    /** Constructor. */
-    ImageReadPropertyGenerator() {
-        super(new String[] {
-                  ImageReadDescriptor.PROPERTY_NAME_RENDERABLE_INPUT},
-              new Class[] {RenderableImage.class},
-              new Class[] {RenderableOp.class});
-    }
-
-    /**
-     * Returns the specified property in the renderable layer.
-     *
-     * @param name   Property name.
-     * @param opNode Operation node.
-     */
-    public Object getProperty(String name,
-                              Object opNode) {
-        // Check arguments.
-        validate(name, opNode);
-
-        // Default to undefined value.
-        Object value = java.awt.Image.UndefinedProperty;
-
-        if(opNode instanceof RenderableOp &&
-           name.equalsIgnoreCase(
-               ImageReadDescriptor.PROPERTY_NAME_RENDERABLE_INPUT)) {
-
-            // Save the node reference and get the hints.
-            RenderableOp node = (RenderableOp)opNode;
-            RenderingHints hints = node.getRenderingHints();
-
-            // Get the CRIF for "ImageRead".
-            OperationRegistry registry = null;
-            ContextualRenderedImageFactory crif = null;
-
-            // Try to get the CRIF from a registry specified in the hints.
-            if(hints != null &&
-               hints.containsKey(JAI.KEY_OPERATION_REGISTRY)) {
-                registry =
-                    (OperationRegistry)hints.get(JAI.KEY_OPERATION_REGISTRY);
-                crif =
-                    (ContextualRenderedImageFactory)registry.getFactory(
-                        RenderableRegistryMode.MODE_NAME, "ImageRead");
-            }
-
-            // If no registry in the hints or that registry does not contain
-            // a CRIF for "ImageRead", try to get it from the default registry.
-            if(crif == null) {
-                registry =
-                    JAI.getDefaultInstance().getOperationRegistry();
-                crif =
-                    (ContextualRenderedImageFactory)registry.getFactory(
-                        RenderableRegistryMode.MODE_NAME, "ImageRead");
-            }
-
-            // Create the RenderableImage and set the property value to it.
-            if(crif != null &&
-               crif instanceof com.sun.media.jai.imageioimpl.ImageReadCRIF) {
-                value = ((com.sun.media.jai.imageioimpl.ImageReadCRIF)crif).createRenderable(
-                            node.getParameterBlock(),
-                            hints);
-            }
-        }
-
-        return value;
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/ImageWriteDescriptor.java zzx2/src/share/classes/com/sun/media/jai/operator/ImageWriteDescriptor.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/ImageWriteDescriptor.java	2005-02-11 00:01:56.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/operator/ImageWriteDescriptor.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,1375 +0,0 @@
-/*
- * $RCSfile: ImageWriteDescriptor.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:56 $
- * $State: Exp $
- */
-package com.sun.media.jai.operator;
-
-import java.awt.Dimension;
-import java.awt.RenderingHints;
-import java.awt.image.BufferedImage;
-import java.awt.image.RenderedImage;
-import java.awt.image.renderable.ParameterBlock;
-import java.awt.image.renderable.RenderableImage;
-import java.io.File;
-import java.io.IOException;
-import java.net.Socket;
-import java.util.Collection;
-import java.util.EventListener;
-import java.util.Iterator;
-import java.util.Locale;
-import javax.imageio.ImageIO;
-import javax.imageio.ImageWriteParam;
-import javax.imageio.ImageWriter;
-import javax.imageio.metadata.IIOMetadata;
-import javax.imageio.spi.ImageWriterSpi;
-import javax.imageio.stream.ImageOutputStream;
-import javax.media.jai.CollectionOp;
-import javax.media.jai.JAI;
-import javax.media.jai.OperationDescriptorImpl;
-import javax.media.jai.RenderableOp;
-import javax.media.jai.RenderedOp;
-import javax.media.jai.registry.CollectionRegistryMode;
-import javax.media.jai.registry.RenderableRegistryMode;
-import javax.media.jai.registry.RenderedRegistryMode;
-
-/**
- * An <code>OperationDescriptor</code> describing the "ImageWrite" operation.
- *
- * <p>The "ImageWrite" operation uses the
- * <a href="http://java.sun.com/j2se/1.4/docs/guide/imageio/index.html">Java
- * Image I/O Framework</a> to write images to an output destination. Which
- * formats may be written depends on which {@link javax.imageio.ImageWriter}
- * plug-ins are registered with the Image I/O Framework when the operation is
- * invoked.</p>
- *
- * <p>The output destination will usually be an
- * {@link javax.imageio.stream.ImageOutputStream}, but may be a
- * {@link java.io.File}, {@link java.io.RandomAccessFile},
- * {@link java.io.OutputStream}, {@link java.net.Socket},
- * {@link java.nio.channels.WritableByteChannel}, file path represented as a
- * <code>String</code> or some other type compatible with a writer plug-in. The
- * {@link javax.imageio.ImageIO} class should be used to specify the location
- * and enable the use of cache files via its <code>setCacheDirectory()</code>
- * and <code>setUseCache()</code> methods, respectively. Note that this cache
- * pertains to image stream caching and is unrelated to the JAI
- * <code>TileCache</code>. If an {@link javax.imageio.stream.ImageOutputStream}
- * is created internally by the operation, for example from a
- * {@link java.io.File}-valued <a href="#ParamOutput">Output</a> parameter,
- * then it will be flushed automatically if and only if the operation is not
- * in <a href="#CollectionMode">collection mode</a> and pixel replacement is
- * not occurring.</p>
- *
- * <p>The "ImageWrite" operation supports <a href="#RenderedMode">rendered</a>,
- * <a href="#RenderableMode">renderable</a>, and
- * <a href="#CollectionMode">collection</a> modes and requires a single
- * source. The operation is "immediate" for all modes as specified by
- * <code>OperationDescriptor.isImmediate()</code> so that
- * {@link #isImmediate()} returns <code>true</code>. The operation will
- * therefore be rendered when created via either <code>JAI.create[NS]()</code>
- * or <code>JAI.createCollection[NS]()</code>.
- * A {@link java.awt.RenderingHints} object supplied when the
- * operation is created will have no effect except with respect to the
- * mapping of <code>JAI.KEY_INTERPOLATION</code> and then only in renderable
- * mode.</p>
- *
- * <p>Image properties are used to pass metadata and other information to the
- * writer plug-in and to make available metadata as actually written to the
- * output destination. Property handling is mode-specific.</p>
- *
- * <p><table border=1>
- * <caption><b>Resource List</b></caption>
- * <tr><th>Name</th>        <th>Value</th></tr>
- * <tr><td>GlobalName</td>  <td>ImageWrite</td></tr>
- * <tr><td>LocalName</td>   <td>ImageWrite</td></tr>
- * <tr><td>Vendor</td>      <td>com.sun.media.jai</td></tr>
- * <tr><td>Description</td> <td>Writes an image using the Java Image I/O Framework.</td></tr>
- * <tr><td>DocURL</td>      <td>http://java.sun.com/products/java-media/jai/forDevelopers/jai-imageio-1_0-rc-docs/com/sun/media/jai/operator/ImageWriteDescriptor.html</td></tr>
- * <tr><td>Version</td>     <td>1.0</td></tr>
- * <tr><td>arg0Desc</td>    <td>The output destination.</td></tr>
- * <tr><td>arg1Desc</td>    <td>The format name of the output.</td></tr>
- * <tr><td>arg2Desc</td>    <td>Whether to use image metadata properties as fallbacks.</td></tr>
- * <tr><td>arg3Desc</td>    <td>Whether to transcode metadata before writing.</td></tr>
- * <tr><td>arg4Desc</td>    <td>Whether to verify the validity of the output destination.</td></tr>
- * <tr><td>arg5Desc</td>    <td>Whether to allow pixel replacement in the output image.</td></tr>
- * <tr><td>arg6Desc</td>    <td>The tile size of the output image.</td></tr>
- * <tr><td>arg7Desc</td>    <td>Stream metadata to write to the output.</td></tr>
- * <tr><td>arg8Desc</td>    <td>Image metadata to write to the output.</td></tr>
- * <tr><td>arg9Desc</td>    <td>Thumbnails to write to the output.</td></tr>
- * <tr><td>arg10Desc</td>    <td>EventListeners to be registered with the ImageWriter.</td></tr>
- * <tr><td>arg11Desc</td>    <td>The Locale for the ImageWriter to use.</td></tr>
- * <tr><td>arg12Desc</td>    <td>Java Image I/O write parameter instance.</td></tr>
- * <tr><td>arg13Desc</td>    <td>Java Image I/O writer instance.</td></tr>
- * </table></p>
- *
- * <h2><a name="RenderedMode"</a>Rendered Mode</h2>
- *
- * In rendered mode the "ImageWrite" operation writes a
- * {@link java.awt.image.RenderedImage} to the specified output destination.
- *
- * <h3><a name="RenderedModeParameters"</a>Rendered Mode Parameters</h3>
- *
- * The parameter list of the "ImageWrite" operation in rendered mode is
- * as in the following table.
- *
- * <p><table border=1>
- * <caption><b>Rendered Mode Parameter List</b></caption>
- * <tr><th>Name</th>           <th>Class Type</th>
- *                             <th>Default Value</th></tr>
- * <tr><td><a href="#ParamOutput">
- *     Output</a></td>          <td>java.lang.Object.class</td>
- *                             <td>NO_PARAMETER_DEFAULT</td>
- * <tr><td><a href="#ParamFormat">
- *     Format</a></td>    <td>java.lang.String</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamUseProperties">
- *     UseProperties</a></td>   <td>java.lang.Boolean</td>
- *                             <td>TRUE</td>
- * <tr><td><a href="#ParamTranscode">
- *     Transcode</a></td> <td>java.lang.Boolean</td>
- *                             <td>TRUE</td>
- * <tr><td><a href="#ParamVerifyOutput">
- *     VerifyOutput</a></td>    <td>java.lang.Boolean</td>
- *                             <td>TRUE</td>
- * <tr><td><a href="#ParamAllowPixelReplacement">
- *     AllowPixelReplacement</a></td> <td>java.lang.Boolean</td>
- *                             <td>FALSE</td>
- * <tr><td><a href="#ParamTileSize">
- *     TileSize</a></td>    <td>java.awt.Dimension</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamStreamMetadata">
- *     StreamMetadata</a></td>    <td>javax.imageio.metadata.IIOMetadata</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamImageMetadata">
- *     ImageMetadata</a></td>    <td>javax.imageio.metadata.IIOMetadata</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamThumbnails">
- *     Thumbnails</a></td>    <td>java.awt.BufferedImage[]</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamListeners">
- *     Listeners</a></td>      <td>java.util.EventListener[]</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamLocale">
- *     Locale</a></td>         <td>java.util.Locale</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamWriteParam">
- *     WriteParam</a></td>      <td>javax.imageio.ImageWriteParam</td>
- *                             <td>null</td>
- * <tr><td><a href="#ParamWriter">
- *     Writer</a></td>         <td>javax.imageio.ImageWriter</td>
- *                             <td>null</td>
- * </table></p>
- *
- * <p>The rendered mode parameters are handled as follows:
- *
- * <ul>
- * <p><li><a name="ParamOutput"</a>
- * If Output is a String it is assumed to represent a file path.
- * </li></p>
- * <p><li><a name="ParamFormat"</a>
- * Format will be used to obtain an ImageWriter if one is not supplied. If
- * this parameter is null and Writer is non-null and has an originating
- * ImageWriterSpi, then the first format name listed by that provider will be
- * used. If Writer is null and Output is a File or a String, an attempt will
- * be made to derive the format name from the suffix of the file path. If
- * this fails, then the format will default to "PNG" as this is the most
- * versatile writer plug-in in the Java 2 core.
- * </li></p>
- * <p><li><a name="ParamUseProperties"</a>
- * If UseProperties is TRUE, then if stream or image metadata or thumbnails
- * are not provided as parameters, an attempt will be made to derive them
- * from the source image using the respective image properties previously
- * described for the "ImageRead" operation.
- * </li></p>
- * <p><li><a name="ParamTranscode"</a>
- * If Transcode is TRUE, then any stream or metadata derived either from
- * operation parameters or source image properties will be converted using
- * the ImageWriter's implementation of ImageTranscoder.
- * </li></p>
- * <p><li><a name="ParamVerifyOutput"</a>
- * If VerifyOutput is TRUE, then if the Output is a File or a String it will
- * be verified that a file at the specified location may either be overwritten
- * or created. If Output is a Socket, it will be verified that it is bound,
- * connected, not closed, and its write-half is not shut down. If any of
- * these checks fails, an exception will be thrown when the operation is
- * created. This parameter is ignored for other output types.
- * </li></p>
- * <p><li><a name="ParamAllowPixelReplacement"</a>
- * If AllowPixelReplacement is TRUE, and the ImageWriter supports pixel
- * replacement, then a construct will be enabled to allow "live" updating
- * of the output in response to RenderingChangeEvents or "InvalidRegion"
- * events.
- * </li></p>
- * <p><li><a name="ParamTileSize"</a>
- * TileSize specifies the desired tile size; it is used as defined by the
- * <a href="#RenderedModeTiling">tiling algorithm</a>. This parameter is
- * ignored if the ImageWriter does not support tiling.
- * Regardless of the capabilities of the writer, an exception will be thrown
- * when the operation is created if this parameter is non-null and either
- * its width or height is not positive.
- * </li></p>
- * <p><li><a name="ParamStreamMetadata"</a>
- * If StreamMetadata is non-null, then the parameter will take priority over
- * the corresponding image property as the source of stream metadata to
- * be written.
- * </li></p>
- * <p><li><a name="ParamImageMetadata"</a>
- * If ImageMetadata is non-null, then the parameter will take priority over
- * the corresponding image property as the source of image metadata to
- * be written.
- * </li></p>
- * <p><li><a name="ParamThumbnails"</a>
- * If Thumbnails is non-null, then the parameter will take priority over
- * the corresponding image property as the source of image thumbnails to
- * be written.
- * </li></p>
- * <p><li><a name="ParamListeners"</a>
- * Listeners will be used to set any progress or warning listeners of the
- * ImageWriter. Each element in the java.util.EventListener array will be
- * added for all types of listener it implements. For example if a listener
- * object implements all of the javax.imageio.event.IIOWrite*Listeners
- * interfaces then it will be added as a listener of each of the three types.
- * Any elements in the array which do not implement any of the
- * IIOWrite*Listeners will be ignored.
- * </li></p>
- * <p><li><a name="ParamLocale"</a>
- * Locale will be used to set the Locale of the ImageWriter. This parameter
- * overrides the equivalent setting of the Writer parameter if the latter is
- * also supplied.
- * </li></p>
- * <p><li><a name="ParamWriteParam"</a>
- * If WriteParam is null, an ImageWriteParam will be derived internally using
- * ImageWriter.getDefaultWriteParam().
- * </li></p>
- * <p><li><a name="ParamWriter"</a>
- * If Writer is null, an attempt will be made to find an ImageWriter capable
- * of writing the image. If this attempt to obtain an ImageWriter fails, an
- * exception will be thrown.
- * </li></p>
- * </ul>
- * </p>
- *
- * <h4><a name="SyncPolicy"</a>Parameters and Synchronization Policy</h4>
- *
- * Similarly to the case of any ImageReadParam or ImageReader supplied to the
- * "ImageRead" operation, any ImageWriteParam or ImageWriter supplied to the
- * "ImageWrite" operation is subject to modification within the operation
- * classes. A policy similar to the
- * <a href="./ImageReadDescriptor.html#SyncPolicy">"ImageRead"
- * synchronization policy</a> therefore applies as well for "ImageWrite".
- * 
- * <p>In the Sun Microsystems implementation of this operation these potential
- * conflicts have been mitigated to a certain extent:
- * 
- * <ul>
- * <p><li>
- * If the param is cloneable then it is cloned and the clone used internally.
- *  Otherwise if the param is an instance of ImageWriteParam itself rather than
- *   of a subclass thereof, i.e., getClass().getName() invoked on the param
- *   returns "javax.imageio.ImageWriteParam", then a new ImageWriteParam is
- *   constructed and the settings of the original param copied to it. If the
- *   param is not cloneable and is an instance of a proper subclass of
- *   ImageWriteParam then it is used directly.</li></p>
- * 
- * <p><li>
- * The only ImageWriter methods invoked after rendering are
- *   prepareReplacePixels(int,Rectangle), replacePixels(Raster,ImageWriteParam),
- *   and endReplacePixels() and these are invoked within a method synchronized
- *   on the ImageWriter object.</li></p>
- * </ul>
- * </p>
- *
- * <h3><a name="RenderedModeTiling"</a>Tiling</h3>
- *
- * The following algorithm is used to determine the tile size of the
- * image written to the output destination:
- * 
- * <pre>
- * if ImageWriter cannot write tiles
- *    output is untiled
- * else
- *    if TileSize parameter is non-null
- *       set tile size to TileSize
- *    else
- *       if WriteParam is null
- *          set tile size to source tile size
- *       else
- *          if tilingMode is ImageWriteParam.MODE_EXPLICIT
- *             if tile dimension is set in WriteParam
- *                set tile size to tile dimension from WriteParam
- *             else
- *                if preferred tile dimension is set in WriteParam
- * 		  set tile size to average of first two preferred dimensions
- *                else
- *                   set tile size to source tile size
- *          else // tilingMode is not ImageWriteParam.MODE_EXPLICIT
- *             the plug-in decides the tile size
- * </pre>
- * 
- * There is no mechanism to set the tile grid offsets of the output.
- *
- * <h3><a name="RenderedModePixelReplacement"</a>Pixel Replacement</h3>
- *
- * If AllowPixelReplacement is TRUE, the ImageWriter can replace pixels, and
- * the source is a PlanarImage, then the rendering of the operation
- * will respond to RenderingChangeEvents and Shape-valued PropertyChangeEvents
- * named "InvalidRegion". The rendering will be automatically registered as
- * a sink of the rendering of the operation node's source. As the source
- * rendering does not usually generate events, the calling code must also
- * explicitly register the "ImageWrite" rendering as a sink of the source
- * node. By whatever means the event is generated, when the rendering
- * receives such an event, it will determine the indices of all tiles which
- * overlap the invalid region and will replace the pixels of all these tiles
- * in the output.
- * 
- * <p>Note that this behavior differs from what would happen if the RenderedOp
- * created by the operation received a RenderingChangeEvent: in this case a
- * new rendering of the node would be created using the ParameterBlock and
- * RenderingHints currently in effect. This would cause the entire image to be
- * rewritten at the current position of the output. This will also happen
- * when AllowPixelReplacement is FALSE. In effect in both of these cases the
- * behavior in response to a RenderingChangeEvent is unspecified and the result
- * will likely be unexpected.</p>
- * 
- * <p>To avoid any inadvertent overwriting of the destination as a result of
- * events received by the RenderedOp, the following usage is recommended when
- * the objective is automatic pixel replacement:
- * 
- * <pre>
- *        // Sources, parameters, and hints.
- *        ParameterBlock args;
- *        RenderingHints hints;
- * 
- *        // Create the OperationNode.
- *        RenderedOp imageWriteNode = JAI.create("ImageWrite", args, hints);
- * 
- *        // Get the rendering which already exists due to "immediate" status.
- *        RenderedImage imageWriteRendering = imageWriteNode.getRendering();
- * 
- *        // Unhook the OperationNode as a sink of its source OperationNode.
- *        imageWriteNode.getSourceImage(0).removeSink(imageWriteNode);
- *
- *        // Add the rendering as a sink of the source OperationNode.
- *        imageWriteNode.getSourceImage(0).addSink(imageWriteRendering);
- * 
- *        // Free the OperationNode for garbage collection.
- *        imageWriteNode = null;
- * </pre>
- * 
- * At this point a reference to imageWriteRendering must be held as long as the
- * data of the source of the operation may change. Then provided the events are
- * correctly propagated to imageWriteRendering, the data in the output file
- * will be automatically updated to match the source data.</p>
- * 
- * <p>If pixel replacement is not the objective and inadvertent overwriting is
- * to be avoided then the safest approach would be the following:
- * 
- * <pre>
- *        // Create the OperationNode.
- *        RenderedOp imageWriteNode = JAI.create("ImageWrite", args, hints);
- * 
- *        // Unhook the OperationNode as a sink of its source
- *        imageWriteNode.getSourceImage(0).removeSink(imageWriteNode);
- * </pre>
- * 
- * The image is written by the first statement and no reference to the
- * rendering need be retained as before.
- *
- * <h3><a name="RenderedModeProperties"</a>Image Properties in Rendered Mode</h3>
- *
- * Image properties are used for metadata, thumbnails, and writer-related
- * information. The following properties may be set on the RenderedOp created
- * for the "ImageWrite" operation in rendered mode:
- * 
- * <p><table border=1>
- * <caption><b>Rendered Mode Image Properties</b></caption>
- * <tr>
- * <th>Property Name</th>
- * <th>Type</th>
- * <th>Comment</th>
- * </tr>
- * <tr>
- * <td>JAI.ImageWriteParam</td>
- * <td>ImageWriteParam</td>
- * <td>Set to ImageWriteParam actually used which may differ from the one passed in.</td>
- * </tr>
- * <tr>
- * <td>JAI.ImageWriter</td>
- * <td>ImageWriter</td>
- * <td>Set to ImageWriter actually used.</td>
- * </tr>
- * <tr>
- * <td>JAI.ImageMetadata</td>
- * <td>IIOMetadata</td>
- * <td>Set if and only if image metadata are available; may be transcoded.</td>
- * </tr>
- * <tr>
- * <td>JAI.StreamMetadata</td>
- * <td>IIOMetadata</td>
- * <td>Set if and only if stream metadata are available; may be transcoded.</td>
- * </tr>
- * <tr>
- * <td>JAI.Thumbnails</td>
- * <td>BufferedImage[]</td>
- * <td>Set if and only thumbnails are provided and the writer supportes writing them.</td>
- * </tr>
- * </table></p>
- * 
- * <p>If a given property is not set, this implies of course that the names of
- * absent properties will not appear in the array returned by getPropertyNames()
- * and getProperty() invoked to obtain absent properties will return
- * java.awt.Image.UndefinedProperty as usual.</p>
- * 
- * <p>The ImageWriter and ImageWriteParam may be used for subsequent invocations
- * of the operation or for informational purposes. Care should be taken in using
- * these property values with respect to the synchronization issues previously
- * discussed.</p>
- * 
- * <p>Metadata properties will be set to those actually written to the output. They
- * may be derived either from input parameters or source properties depending on
- * the values of the StreamMetadata, ImageMetadata, and UseProperties parameters.
- * They will be transcoded data if Transcode is TRUE and the ImageWriter supports
- * transcoding.</p>
- * 
- * <p>All properties will be set when the node is rendered.</p>
- *
- * <h2><a name="RenderableMode"</a>Renderable Mode</h2>
- *
- * In renderable mode the "ImageWrite" operation requires a
- * {@link java.awt.image.renderable.RenderableImage} source and writes a
- * {@link java.awt.image.RenderedImage} to the specified output destination.
- * As the "immediate" designation specified by {@link #isImmediate()}
- * has no effect in renderable mode, no image will be written without further
- * action by the calling code. To write an image, createRendering(),
- * createScaledRendering(), or createDefaultRendering()
- * must be invoked. Each of these will create a RenderedImage by forwarding the
- * createRendering() or equivalent call to the source image. The resulting
- * RenderedImage will be written to the output according to the
- * <a href="#RenderedMode">rendered mode</a> operation of "ImageWrite".
- * If a mapping of <code>JAI.KEY_INTERPOLATION</code> is supplied via a
- * <code>RenderingHints</code> passed to the operation, then the interpolation
- * type it specifies will be used to create the rendering if interpolation is
- * required.
- *
- * <h3><a name="RenderableModeParameters"</a>Renderable Mode Parameters</h3>
- *
- * The parameter list of the "ImageRead" operation in renderable mode is
- * identical to the <a href="#RenderedModeParameters">rendered mode
- * parameter list</a>.
- *
- * <h3>Pixel Replacement in Renderable Mode</h3>
- *
- * Pixel replacement pertains only to RenderedImages generated by rendering the
- * RenderableOp. It may occur if the same conditions apply as described for
- * pixel replacement in rendered mode. Due to the unspecified nature of the
- * underlying rendered sources of any rendering, this is not a recommended
- * procedure.
- *
- * <h3>Image Properties in Renderable Mode</h3>
- *
- * The RenderableOp node itself does not have any ImageWrite-related
- * properties. Any RenderedImages created by rendering the RenderableOp
- * (thereby writing an image to the output as described), may have
- * <a href="#RenderedModeProperties">rendered mode properties</a> set.
- *
- * <h2><a name="CollectionMode"</a>Collection Mode</h2>
- *
- * In collection mode the "ImageWrite" operation requires a
- * {@link java.util.Collection} source and writes its contents to the
- * specified output destination.
- *
- * <p>The Collection is treated as a sequence of images which will be
- * extracted from the Collection in the order returned by a new Iterator.
- * Elements in the Collection which are not RenderedImages will be ignored.
- * The derived sequence of images will then be written to the output.</p>
- * 
- * <p>If there is only one RenderedImage in the source Collection, this image
- * will be written as done in rendered mode operation. If there is more than
- * one RenderedImage, the sequence of RenderedImages will be written as an
- * image sequence. In the latter case the ImageWriter must be able to write
- * sequences.</p>
- *
- * <h3><a name="CollectionModeParameters"</a>Collection Mode Parameters</h3>
- *
- * Identical parameter list to rendered mode except:
- * 
- * <p><table border=1>
- * <caption><b>Collection Mode Parameter Differences</b></caption>
- * <tr><th>Name</th>           <th>Class Type</th>
- *                             <th>Default Value</th></tr>
- * <tr><td>ImageMetadata</td>  <td>javax.imageio.metadataIIOMetadata[]</td>
- *                             <td>null</td>
- * <tr><td>Thumbnails</td>     <td>java.awt.image.BufferedImage[][]</td>
- *                             <td>null</td>
- * </table></p>
- * 
- * <ul>
- * <p><li>
- * If the source is not a CollectionOp then the number of RenderedImages in
- * the source is counted. If it is not at least one then an exception is
- * thrown when the operation is created. If it is greater than one, then
- * the ImageWriter is checked to determine whether it can write sequences.
- * If it cannot then an exception is thrown when the operation is created.
- * </li></p>
- * <p><li>
- * The first index of the thumbnails array corresponds to the ordinal position
- * of the image in the collection and the second index to the thumbnails of
- * that image.
- * </li></p>
- * </ul>
- * 
- * <p>
- * The change to the ImageMetadata and Thumbnails parameters is that there can
- * now be a distinct image metadata object and thumbnail array for each image
- * in the Collection. The components of these respective arrays will be indexed
- * using the sequence of RenderedImages extracted from the source Collection by
- * the Iterator. It is the responsibility of the caller to ensure that this
- * sequencing is correct. In this context it is advisable to use a source
- * Collection which maintains the order of its elements such as a List.
- * </p>
- *
- * <h3>Pixel Replacement in Collection Mode</h3>
- *
- * If the value of the AllowPixelReplacement parameter is TRUE, then the
- * rendered Collection will contain RenderedImages which are registered as
- * listeners of their respective sources. Each image in the rendered Collection
- * will however be a rendering as opposed to a RenderedOp. This obviates the
- * need to unhook such a RenderedOp from its source as suggested. Two actions
- * on the part of the application are however necessary in this case:  1) the
- * sequence must be manually ended, and 2) the Collection node must be removed
- * as a sink of its source Collection. The first action is necessary as
- * pixels may be replaced at various times in various images in the sequence
- * and it is not possible to terminate the sequence at rendering time, and there
- * is no reliable mechanism to detect programmatically when this may later be
- * effected. The second action is necessary because a CollectionChangeEvent
- * received by the Collection node would cause the node to be re-rendered, i.e.,
- * the collection data to be rewritten using the current state of all parameters.
- * This will in fact also happen when AllowPixelReplacement is FALSE. In effect
- * in both of these cases the behavior in response to a CollectionChangeEvent
- * is unspecified and the result will likely be unexpected.
- * 
- * <p>
- * To ensure proper termination of the image sequence and avoid any inadvertent
- * overwriting of the destination as a result of events received by the
- * CollectionOp, the following usage is recommended when the objective is
- * automatic pixel replacement:
- * 
- * <pre>
- *        // Sources, parameters, and hints.
- *        ParameterBlock args;
- *        RenderingHints hints;
- * 
- *        // Create the Collection.
- *        CollectionImage imageWriteCollection =
- *            (CollectionImage)JAI.createCollection("ImageWrite", args, hints);
- * 
- *        // Unhook the Collection node from the source to avoid
- *        // re-renderings caused by CollectionChangeEvents.
- *        if(args.getSource(0) instanceof CollectionImage) {
- *            CollectionImage sourceCollection =
- * 	       (CollectionImage)args.getSource(0);
- *            sourceCollection.removeSink(imageWriteCollection);
- *        }
- * 
- *        // !!! Pixel replacement activity happens here ... !!!
- * 
- *        // Get the ImageWriter.
- *        ImageWriter writer =
- *            (ImageWriter)imageWriteCollection.getProperty("JAI.ImageWriter");
- * 
- *        // End the sequence if necessary.
- *        if(writer.canWriteSequence()) {
- *            writer.endWriteSequence();
- *        }
- * </pre>
- * </p>
- * 
- * <p>
- * Using the foregoing construct, all pixels in all images written to the output
- * sequence will remain current with the in-memory data of their respective
- * source provided all events are propagated as expected. Note that it is not
- * necessary to end the sequence manually if pixel replacement is not allowed or
- * is not supported. Also the sequence must be manually ended if and only if the
- * writer is capable of writing sequences. This permits pixel replacement to
- * work in the case where the source collection contains only a single image
- * and the writer supports pixel replacement but cannot write sequences.
- * </p>
- * 
- * <p>
- * If pixel replacement is not the objective, i.e., AllowPixelReplacement is
- * FALSE, and inadvertent overwriting is to be avoided then the safest approach
- * would be the following:
- * 
- * <pre>
- *        // Create the Collection.
- *        Collection imageWriteCollection =
- *            JAI.create("ImageWrite", args, hints);
- * 
- *        // Unhook the Collection node from the source to avoid
- *        // re-renderings caused by CollectionChangeEvents.
- *        if(args.getSource(0) instanceof CollectionImage) {
- *            CollectionImage sourceCollection =
- * 	       (CollectionImage)args.getSource(0);
- *            sourceCollection.removeSink(imageWriteCollection);
- *        }
- * </pre>
- * 
- * The image is written by the first statement and no reference to the
- * rendering need be retained.</p>
- *
- * <h3>Image Properties in Collection Mode</h3>
- *
- * Contingent on parameter settings and the presence of the appropriate
- * metadata, the rendered Collection may have the "JAI.StreamMetadata",
- * "JAI.ImageReadParam", and "JAI.ImageReader" properties set. Each
- * RenderedImage in the Collection may contain
- * <a href="#RenderedModeProperties">rendered mode properties</a>
- * contingent on parameter settings and data availability. Metadata
- * properties may be transcoded.
- *
- * @see javax.media.jai.OperationDescriptor
- * @see javax.imageio.ImageWriter
- * @see javax.imageio.ImageWriteParam
- * @see javax.imageio.metadata.IIOMetadata
- * @see javax.imageio.stream.ImageOutputStream
- */
-public class ImageWriteDescriptor extends OperationDescriptorImpl {
-
-    // Property name constants have package access for image factory use.
-
-    /** ImageWriteParam property name "JAI.ImageWriteParam". */
-    public static final String PROPERTY_NAME_IMAGE_WRITE_PARAM =
-        "JAI.ImageWriteParam";
-
-    /** ImageWriter property name "JAI.ImageWriter". */
-    public static final String PROPERTY_NAME_IMAGE_WRITER =
-        "JAI.ImageWriter";
-
-    /**
-     * Image metadata property name. Set to same value as
-     * {@link ImageReadDescriptor#PROPERTY_NAME_METADATA_IMAGE}.
-     */
-    public static final String PROPERTY_NAME_METADATA_IMAGE =
-        ImageReadDescriptor.PROPERTY_NAME_METADATA_IMAGE;
-
-    /**
-     * Stream metadata property name. Set to same value as
-     * {@link ImageReadDescriptor#PROPERTY_NAME_METADATA_STREAM}.
-     */
-    public static final String PROPERTY_NAME_METADATA_STREAM =
-        ImageReadDescriptor.PROPERTY_NAME_METADATA_STREAM;
-
-    /**
-     * Thumbnail property name. Set to same value as
-     * {@link ImageReadDescriptor#PROPERTY_NAME_THUMBNAILS}.
-     */
-    public static final String PROPERTY_NAME_THUMBNAILS =
-        ImageReadDescriptor.PROPERTY_NAME_THUMBNAILS;
-
-    /**
-     * Test method.
-     *
-     * @param args {inputFile, outputFile [, mode]}
-     * @throws Throwable any error.
-     */
-    /* XXX
-    public static void main(String[] args) throws Throwable {
-        String inputFile = args[0];
-        String outputFile = args[1];
-        String modeName = args.length > 2 ?
-            args[2] : RenderedRegistryMode.MODE_NAME;
-        String formatName = args.length > 3 ?
-            args[3] : null;
-
-        ParameterBlock pb = new ParameterBlock();
-        pb.set(new java.io.File(outputFile), 0);
-        if(formatName != null) {
-            pb.set(formatName, 1);
-        }
-
-        java.awt.image.RenderedImage[] images = null;
-        if(modeName.equalsIgnoreCase(RenderedRegistryMode.MODE_NAME)) {
-            pb.addSource(ImageIO.read(new java.io.File(inputFile)));
-            images = new java.awt.image.RenderedImage[1];
-            pb.set(new Dimension(128, 128), 6);
-            images[0] = JAI.create("ImageWrite", pb, null);
-            PrintProps.print((javax.media.jai.PropertySource)images[0]);
-        } else if(modeName.equalsIgnoreCase(RenderableRegistryMode.MODE_NAME)) {
-            ParameterBlock renderablePB = new ParameterBlock();
-            renderablePB.addSource(ImageIO.read(new java.io.File(inputFile)));
-            pb.addSource(javax.media.jai.JAI.createRenderable("renderable", renderablePB));
-            java.awt.image.renderable.RenderableImage ri =
-                JAI.createRenderable("ImageWrite", pb, null);
-            PrintProps.print((javax.media.jai.PropertySource)ri);
-            images = new java.awt.image.RenderedImage[1];
-            //java.awt.image.renderable.RenderContext rc =
-            //    new java.awt.image.renderable.RenderContext(
-            //        new java.awt.geom.AffineTransform(42, 0, 0, 42, 0, 0));
-            //images[0] = ri.createRendering(rc);
-            images[0] = ri.createDefaultRendering();
-            PrintProps.print((javax.media.jai.PropertySource)images[0]);
-        } else if(modeName.equalsIgnoreCase(CollectionRegistryMode.MODE_NAME)) {
-            java.util.ArrayList sourceCollection = new java.util.ArrayList();
-            Object input =
-                ImageIO.createImageInputStream(new java.io.File(inputFile));
-            javax.imageio.ImageReader reader =
-                (javax.imageio.ImageReader)ImageIO.getImageReaders(input).next();
-            reader.setInput(input);
-            int imageIndex = 0;
-            do {
-                try {
-                    RenderedImage nextImage = reader.read(imageIndex);
-                    sourceCollection.add(nextImage);
-                } catch(IndexOutOfBoundsException e) {
-                    break;
-                }
-                imageIndex++;
-            } while(true);
-            pb.addSource(sourceCollection);
-            java.util.Collection imageCollection =
-                JAI.createCollection("ImageWrite", pb, null);
-            PrintProps.print((javax.media.jai.PropertySource)imageCollection);
-            images = new java.awt.image.RenderedImage[imageCollection.size()];
-            imageCollection.toArray(images);
-        } else {
-            throw new UnsupportedOperationException(modeName+" mode not supported");
-        }
-
-        final java.awt.Frame frame = new java.awt.Frame();
-        frame.addWindowListener(new java.awt.event.WindowAdapter() {
-                public void windowClosing(java.awt.event.WindowEvent e) {
-                    frame.setEnabled(false);
-                    frame.dispose();
-                }
-            });
-
-        int gridSide = (int)(Math.sqrt(images.length) + 0.5);
-        frame.setLayout(new java.awt.GridLayout(gridSide, gridSide));
-        java.awt.Dimension screenSize =
-            java.awt.Toolkit.getDefaultToolkit().getScreenSize();
-        int width =
-            Math.min(screenSize.width/gridSide, images[0].getWidth());
-        int height =
-            Math.min(screenSize.height/gridSide, images[0].getHeight());
-        for(int i = 0; i < images.length; i++) {
-            javax.media.jai.widget.ScrollingImagePanel panel =
-                new javax.media.jai.widget.ScrollingImagePanel(images[i],
-                                                               width, //image.getWidth(),
-                                                               height);//image.getHeight());
-            frame.add(panel);
-        }
-        frame.pack();
-        frame.show();
-    }
-    */
-
-    /**
-     * The name of the operation.
-     */
-    private static final String OPERATION_NAME = "ImageWrite";
-
-    /**
-     * The resource strings that provide the general documentation and
-     * specify the parameter list for the "ImageWrite" operation.
-     */
-    private static final String[][] resources = {
-        {"GlobalName",  "ImageWrite"},
-        {"LocalName",   "ImageWrite"},
-        {"Vendor",      "com.sun.media.jai"},
-        {"Description", I18N.getString("ImageWriteDescriptor0")},
-        {"DocURL",      "http://java.sun.com/products/java-media/jai/forDevelopers/jai-apidocs/javax/media/jai/operator/ImageWriteDescriptor.html"},
-        {"Version",     I18N.getString("DescriptorVersion")},
-        {"arg0Desc",    I18N.getString("ImageWriteDescriptor1")},
-        {"arg1Desc",    I18N.getString("ImageWriteDescriptor2")},
-        {"arg2Desc",    I18N.getString("ImageWriteDescriptor3")},
-        {"arg3Desc",    I18N.getString("ImageWriteDescriptor4")},
-        {"arg4Desc",    I18N.getString("ImageWriteDescriptor5")},
-        {"arg5Desc",    I18N.getString("ImageWriteDescriptor6")},
-        {"arg6Desc",    I18N.getString("ImageWriteDescriptor7")},
-        {"arg7Desc",    I18N.getString("ImageWriteDescriptor8")},
-	{"arg8Desc",    I18N.getString("ImageWriteDescriptor9")},
-	{"arg9Desc",    I18N.getString("ImageWriteDescriptor10")},
-	{"arg10Desc",    I18N.getString("ImageWriteDescriptor11")},
-	{"arg11Desc",    I18N.getString("ImageWriteDescriptor12")},
-	{"arg12Desc",    I18N.getString("ImageWriteDescriptor13")},
-	{"arg13Desc",    I18N.getString("ImageWriteDescriptor14")}
-    };
-
-    /** The parameter names for the "ImageWrite" operation. */
-    private static final String[] paramNames = {
-        "Output", "Format", "UseProperties", "Transcode",
-        "VerifyOutput", "AllowPixelReplacement", "TileSize",
-        "StreamMetadata", "ImageMetadata", "Thumbnails",
-        "Listeners", "Locale", "WriteParam", "Writer"
-    };
-
-    /** The parameter class types for rendered mode of "ImageWrite". */
-    private static final Class[] renderedParamClasses = {
-        java.lang.Object.class,                   // Output
-        java.lang.String.class,                   // Format
-	java.lang.Boolean.class,                  // UseProperties
-	java.lang.Boolean.class,                  // Transcode
-	java.lang.Boolean.class,                  // VerifyOutput
-	java.lang.Boolean.class,                  // AllowPixelReplacement
-	java.awt.Dimension.class,                 // TileSize
-	javax.imageio.metadata.IIOMetadata.class, // StreamMetadata
-	javax.imageio.metadata.IIOMetadata.class, // ImageMetadata
-        java.awt.image.BufferedImage[].class,     // Thumbnails
-        java.util.EventListener[].class,          // Listeners
-        java.util.Locale.class,                   // Locale
-	javax.imageio.ImageWriteParam.class,      // WriteParam
-	javax.imageio.ImageWriter.class           // Writer
-    };
-
-    /** The parameter default values for rendered mode of "ImageWrite". */
-    private static final Object[] renderedParamDefaults = {
-        NO_PARAMETER_DEFAULT, // Output
-        null,                 // Format
-        Boolean.TRUE,         // UseProperties
-        Boolean.TRUE,         // Transcode
-        Boolean.TRUE,         // VerifyOutput
-        Boolean.FALSE,        // AllowPixelReplacement
-        null,                 // TileSize
-        null,                 // StreamMetadata
-        null,                 // ImageMetadata
-        null,                 // Thumbnails
-        null,                 // Listeners
-        null,                 // Locale
-        null,                 // WriteParam
-        null                  // Writer
-    };
-
-    /** The parameter class types for renderable mode of "ImageWrite". */
-    private static final Class[] renderableParamClasses =
-        renderedParamClasses;
-
-    /** The parameter default values for renderable mode of "ImageWrite". */
-    private static final Object[] renderableParamDefaults =
-        renderedParamDefaults;
-
-    /** The parameter class types for collection mode of "ImageWrite". */
-    private static final Class[] collectionParamClasses = {
-        java.lang.Object.class,                     // Output
-        java.lang.String.class,                     // Format
-	java.lang.Boolean.class,                    // UseProperties
-	java.lang.Boolean.class,                    // Transcode
-	java.lang.Boolean.class,                    // VerifyOutput
-	java.lang.Boolean.class,                    // AllowPixelReplacement
-	java.awt.Dimension.class,                   // TileSize
-	javax.imageio.metadata.IIOMetadata.class,   // StreamMetadata
-	javax.imageio.metadata.IIOMetadata[].class, // ImageMetadata
-        java.awt.image.BufferedImage[][].class,     // Thumbnails
-        java.util.EventListener[].class,            // Listeners
-        java.util.Locale.class,                     // Locale
-	javax.imageio.ImageWriteParam.class,        // WriteParam
-	javax.imageio.ImageWriter.class             // Writer
-    };
-
-    /** The parameter default values for collection mode of "ImageWrite". */
-    private static final Object[] collectionParamDefaults =
-        renderedParamDefaults;
-
-    /** Constructor. */
-    public ImageWriteDescriptor() {
-        super(resources,
-              new String[] {RenderedRegistryMode.MODE_NAME,
-                            RenderableRegistryMode.MODE_NAME,
-                            CollectionRegistryMode.MODE_NAME},
-              null, // sourceNames
-              new Class[][] {{RenderedImage.class},
-                             {RenderableImage.class},
-                             {Collection.class}}, // sourceClasses
-              paramNames,
-              new Class[][] {renderedParamClasses,
-                             renderableParamClasses,
-                             collectionParamClasses},
-              new Object[][] {renderedParamDefaults,
-                              renderableParamDefaults,
-                              collectionParamDefaults},
-              new Object[][] {null, null, null}); // validParamValues
-    }
-
-    /**
-     * Type-safe convenience method for creating a {@link RenderedOp}
-     * representing the "ImageWrite" operation in rendered mode. The
-     * method packs the source and parameters into a new
-     * <code>ParameterBlock</code> and invokes
-     * {@link JAI#create(String,ParameterBlock,RenderingHints)}.
-     *
-     * @param source The image to be written.
-     * @param output The output destination.
-     * @param format The format name of the output.
-     * @param useProperties Whether to use image metadata properties as
-     * fallbacks.
-     * @param transcode Whether to transcode metadata before writing.
-     * @param verifyOutput Whether to verify the validity of the output
-     * destination.
-     * @param allowPixelReplacement Whether to allow pixel replacement
-     * in the output image.
-     * @param tileSize The tile size of the output image.
-     * @param streamMetadata Stream metadata to write to the output.
-     * @param imageMetadata Image metadata to write to the output.
-     * @param thumbnails Thumbnails to write to the output.
-     * @param listeners EventListeners to be registered with the ImageWriter.
-     * @param locale The Locale for the ImageWriter to use.
-     * @param writeParam Java Image I/O write parameter instance.
-     * @param writer Java Image I/O writer instance.
-     * @param hints Operation hints.
-     * @return a reference to the operation source.
-     */
-    public static RenderedOp create(RenderedImage source,
-                                    ImageOutputStream output,
-                                    String format,
-                                    Boolean useProperties,
-                                    Boolean transcode,
-                                    Boolean verifyOutput,
-                                    Boolean allowPixelReplacement,
-                                    Dimension tileSize,
-                                    IIOMetadata streamMetadata,
-                                    IIOMetadata imageMetadata,
-                                    BufferedImage[] thumbnails,
-                                    EventListener[] listeners,
-                                    Locale locale,
-                                    ImageWriteParam writeParam,
-                                    ImageWriter writer,
-                                    RenderingHints hints) {
-
-        ParameterBlock args = new ParameterBlock();
-
-        args.addSource(source);
-
-        args.add(output);
-        args.add(format);
-        args.add(useProperties);
-        args.add(transcode);
-        args.add(verifyOutput);
-        args.add(allowPixelReplacement);
-        args.add(tileSize);
-        args.add(streamMetadata);
-        args.add(imageMetadata);
-        args.add(thumbnails);
-        args.add(listeners);
-        args.add(locale);
-        args.add(writeParam);
-        args.add(writer);
-
-        return JAI.create(OPERATION_NAME, args, hints);
-    }
-
-    /**
-     * Type-safe convenience method for creating a {@link Collection}
-     * representing the "ImageWrite" operation in collection mode. The
-     * method packs the source and parameters into a new
-     * <code>ParameterBlock</code> and invokes
-     * {@link JAI#createCollection(String,ParameterBlock,RenderingHints)}.
-     *
-     * @param source The collection to be written.
-     * @param output The output destination.
-     * @param format The format name of the output.
-     * @param useProperties Whether to use image metadata properties as
-     * fallbacks.
-     * @param transcode Whether to transcode metadata before writing.
-     * @param verifyOutput Whether to verify the validity of the output
-     * destination.
-     * @param allowPixelReplacement Whether to allow pixel replacement
-     * in the output image.
-     * @param tileSize The tile size of the output image.
-     * @param streamMetadata Stream metadata to write to the output.
-     * @param imageMetadata Image metadata to write to the output.
-     * @param thumbnails Thumbnails to write to the output.
-     * @param listeners EventListeners to be registered with the ImageWriter.
-     * @param locale The Locale for the ImageWriter to use.
-     * @param writeParam Java Image I/O write parameter instance.
-     * @param writer Java Image I/O writer instance.
-     * @param hints Operation hints.
-     * @return a reference to the operation source.
-     */
-    public static Collection createCollection(Collection source,
-                                              ImageOutputStream output,
-                                              String format,
-                                              Boolean useProperties,
-                                              Boolean transcode,
-                                              Boolean verifyOutput,
-                                              Boolean allowPixelReplacement,
-                                              Dimension tileSize,
-                                              IIOMetadata streamMetadata,
-                                              IIOMetadata[] imageMetadata,
-                                              BufferedImage[][] thumbnails,
-                                              EventListener[] listeners,
-                                              Locale locale,
-                                              ImageWriteParam writeParam,
-                                              ImageWriter writer,
-                                              RenderingHints hints) {
-
-        ParameterBlock args = new ParameterBlock();
-
-        args.addSource(source);
-
-        args.add(output);
-        args.add(format);
-        args.add(useProperties);
-        args.add(transcode);
-        args.add(verifyOutput);
-        args.add(allowPixelReplacement);
-        args.add(tileSize);
-        args.add(streamMetadata);
-        args.add(imageMetadata);
-        args.add(thumbnails);
-        args.add(listeners);
-        args.add(locale);
-        args.add(writeParam);
-        args.add(writer);
-
-        return JAI.createCollection(OPERATION_NAME, args, hints);
-    }
-
-    /**
-     * Type-safe convenience method for creating a {@link RenderableOp}
-     * representing the "ImageWrite" operation in renderable mode. The
-     * method packs the source and parameters into a new
-     * <code>ParameterBlock</code> and invokes
-     * {@link JAI#createRenderable(String,ParameterBlock,RenderingHints)}.
-     *
-     * @param source The renderable source to be written.
-     * @param output The output destination.
-     * @param format The format name of the output.
-     * @param useProperties Whether to use image metadata properties as
-     * fallbacks.
-     * @param transcode Whether to transcode metadata before writing.
-     * @param verifyOutput Whether to verify the validity of the output
-     * destination.
-     * @param allowPixelReplacement Whether to allow pixel replacement
-     * in the output image.
-     * @param tileSize The tile size of the output image.
-     * @param streamMetadata Stream metadata to write to the output.
-     * @param imageMetadata Image metadata to write to the output.
-     * @param thumbnails Thumbnails to write to the output.
-     * @param listeners EventListeners to be registered with the ImageWriter.
-     * @param locale The Locale for the ImageWriter to use.
-     * @param writeParam Java Image I/O write parameter instance.
-     * @param writer Java Image I/O writer instance.
-     * @param hints Operation hints.
-     * @return a reference to the operation source.
-     */
-    public static RenderableOp createRenderable(RenderableImage source,
-                                                ImageOutputStream output,
-                                                String format,
-                                                Boolean useProperties,
-                                                Boolean transcode,
-                                                Boolean verifyOutput,
-                                                Boolean allowPixelReplacement,
-                                                Dimension tileSize,
-                                                IIOMetadata streamMetadata,
-                                                IIOMetadata imageMetadata,
-                                                BufferedImage[] thumbnails,
-                                                EventListener[] listeners,
-                                                Locale locale,
-                                                ImageWriteParam writeParam,
-                                                ImageWriter writer,
-                                                RenderingHints hints) {
-        ParameterBlock args = new ParameterBlock();
-
-        args.addSource(source);
-
-        args.add(output);
-        args.add(format);
-        args.add(useProperties);
-        args.add(transcode);
-        args.add(verifyOutput);
-        args.add(allowPixelReplacement);
-        args.add(tileSize);
-        args.add(streamMetadata);
-        args.add(imageMetadata);
-        args.add(thumbnails);
-        args.add(listeners);
-        args.add(locale);
-        args.add(writeParam);
-        args.add(writer);
-
-        return JAI.createRenderable(OPERATION_NAME, args, hints);
-    }
-
-    /**
-     * Returns true indicating that the operation should be rendered
-     * immediately during a call to <code>JAI.create[]()</code> or
-     * <code>JAI.createCollection[NS]()</code>.
-     *
-     * @see javax.media.jai.OperationDescriptor
-     */
-    public boolean isImmediate() {
-        return true;
-    }
-
-    /**
-     * Validates the parameters in the supplied <code>ParameterBlock</code>.
-     *
-     * <p>In addition to the standard validation performed by the
-     * corresponding superclass method, this method verifies the following:
-     * <ul>
-     * <li>if <i>VerifyOutput</i> is <code>TRUE</code> and <i>Output</i>
-     * is a <code>File</code> or <code>String</code>, whether the
-     * corresponding physical file is writable, i.e., exists and may
-     * be overwritten or does not exist and may be created; and</li>
-     * <li>if <i>VerifyOutput</i> is <code>TRUE</code> and <i>Output</i>
-     * is a <code>Socket</code>, whether it is bound, connected, open,
-     * and the write-half is not shut down; and</li>
-     * <li>if in collection mode (<code>modeName</code> equals
-     * {@link CollectionRegistryMode#MODE_NAME}), the source is not a
-     * {@link CollectionOp}, and the size of the source
-     * {@link Collection} is greater than unity, whether the
-     * {@link ImageWriter} <i>cannot</i> write sequences.</li>
-     * </ul>
-     *
-     * If the superclass method finds that the arguments are invalid, or if
-     * this method determines that any of the foregoing conditions is true,
-     * an error message will be appended to <code>msg</code> and
-     * <code>false</code> will be returned; otherwise <code>true</code> will
-     * be returned.</p>
-     *
-     * @param modeName The operation mode.
-     * @param args The source and parameters of the operation.
-     * @param msg A container for any error messages.
-     *
-     * @return Whether the supplied parameters are valid.
-     */
-    protected boolean validateParameters(String modeName,
-                                         ParameterBlock args,
-                                         StringBuffer msg) {
-        if (!super.validateParameters(modeName, args, msg)) {
-            return false;
-        }
-
-        // Get the Output parameter.
-        Object output = args.getObjectParameter(0);
-
-        // Check the output if so requested by "VerifyOutput".
-	Boolean verifyOutput = (Boolean)args.getObjectParameter(4);
-	if (verifyOutput.booleanValue()){
-            if(output instanceof File || output instanceof String) {
-                // Set file and path variables.
-                File file = null;
-                String path = null;
-                if(output instanceof File) {
-                    file = (File)output;
-                    path = file.getPath();
-                } else if(output instanceof String) {
-                    path = (String)output;
-                    file = new File(path);
-                }
-
-                // Perform non-destructive test that the file
-                // may be created and written.
-                try {
-                    if (file.exists()) {
-                        if (!file.canWrite()) {
-                            // Cannot write to existing file.
-                            msg.append(file.getPath() + " " +
-                                       I18N.getString("ImageWriteDescriptor15"));
-                            return false;
-                        }
-                    } else {
-                        if (!file.createNewFile()) {
-                            // Cannot create file.
-                            msg.append(file.getPath() + " " +
-                                       I18N.getString("ImageWriteDescriptor16"));
-                            return false;
-                        }
-                        file.delete();
-                    }
-                } catch (IOException ioe) {
-                    // I/O exception during createNewFile().
-                    msg.append(file.getPath() + " " +
-                               I18N.getString("ImageWriteDescriptor17") + " " +
-                               ioe.getMessage());
-                    return false;
-                } catch (SecurityException se) {
-                    // Security exception during exists(), canWrite(),
-                    // createNewFile(), or delete().
-                    msg.append(file.getPath() + " " +
-                               I18N.getString("ImageWriteDescriptor18") + " " +
-                               se.getMessage());
-                    return false;
-                }
-            } else if(output instanceof Socket) {
-                Socket socket = (Socket)output;
-
-                if(socket.isOutputShutdown()) {
-                    msg.append("\"" + socket + "\": " + 
-                               I18N.getString("ImageWriteDescriptor19"));
-                    return false;
-                } else if(socket.isClosed()) {
-                    msg.append("\"" + socket + "\": " + 
-                               I18N.getString("ImageWriteDescriptor20"));
-                    return false;
-                } else if(!socket.isBound()) {
-                    msg.append("\"" + socket + "\": " + 
-                               I18N.getString("ImageWriteDescriptor21"));
-                    return false;
-                } else if(!socket.isConnected()) {
-                    msg.append("\"" + socket + "\": " + 
-                               I18N.getString("ImageWriteDescriptor22"));
-                    return false;
-                }
-            }
-        }
-
-        // Get the Format parameter.
-        String format = (String)args.getObjectParameter(1);
-
-        // Get the ImageWriter parameter.
-        ImageWriter writer = (ImageWriter)args.getObjectParameter(13);
-
-        if(format == null) {
-            // Attempt to get the format from the ImageWriter provider.
-            if(writer != null) {
-
-                // Get the SPI.
-                ImageWriterSpi spi = writer.getOriginatingProvider();
-
-                // Set from the SPI.
-                if(spi != null) {
-                    format = spi.getFormatNames()[0];
-                }
-            }
-
-            // Attempt to deduce the format from the file suffix.
-            if(format == null &&
-               (output instanceof File || output instanceof String)) {
-
-                // Set the file name string.
-                String name = output instanceof File ?
-                    ((File)output).getName() : (String)output;
-
-                // Extract the suffix.
-                String suffix = name.substring(name.lastIndexOf(".") + 1);
-
-                // Get the writers of that suffix.
-                Iterator writers = ImageIO.getImageWritersBySuffix(suffix);
-
-                if(writers != null) {
-                    // Get the first writer.
-                    writer = (ImageWriter)writers.next();
-
-                    if(writer != null) {
-                        // Get the SPI.
-                        ImageWriterSpi spi = writer.getOriginatingProvider();
-
-                        // Set from the SPI.
-                        if(spi != null) {
-                            format = spi.getFormatNames()[0];
-                        }
-                    }
-                }
-            }
-
-            // Default to the most versatile core Java Image I/O writer.
-            if(format == null) {
-                format = "PNG";
-            }
-
-            // Replace the format setting.
-            if(format != null) {
-                args.set(format, 1);
-            }
-        }
-
-        // Check the tile size parameter if present.
-        Dimension tileSize = (Dimension)args.getObjectParameter(6);
-        if(tileSize != null && (tileSize.width <= 0 || tileSize.height <= 0)) {
-            msg.append(I18N.getString("ImageWriteDescriptor23"));
-            return false;
-        }
-
-        // For collection mode, verify that the source collection contains
-        // at least one RenderedImage and that the writer can handle sequences
-        // if there is more than one RenderedImage in the source collection.
-        if(modeName.equalsIgnoreCase(CollectionRegistryMode.MODE_NAME)) {
-            // Get the source collection.
-            Collection source = (Collection)args.getSource(0);
-
-            // If the source collection is a CollectionOp do not perform this
-            // check as invoking source.size() will render the node.
-            if(!(source instanceof CollectionOp)) {
-
-                // Determine the number of RenderedImages in the Collection.
-                int numRenderedImages = 0;
-                Iterator iter = source.iterator();
-                while(iter.hasNext()) {
-                    if(iter.next() instanceof RenderedImage) {
-                        numRenderedImages++;
-                    }
-                }
-
-                if(numRenderedImages == 0) {
-                    msg.append(I18N.getString("ImageWriteDescriptor24"));
-                    return false;
-                } else if(numRenderedImages > 1) {
-                    // Get the writer parameter.
-                    writer = (ImageWriter)args.getObjectParameter(13);
-
-                    // If the parameter writer is null, get one based on the
-                    // format.
-                    if(writer == null && format != null) {
-                        // Get the writers of that format.
-                        Iterator writers =
-                            ImageIO.getImageWritersByFormatName(format);
-
-                        if(writers != null) {
-                            // Get the first writer.
-                            writer = (ImageWriter)writers.next();
-                        }
-                    }
-
-                    if(writer != null) {
-                        // Check that the writer can write sequences.
-                        if(!writer.canWriteSequence()) {
-                            msg.append(I18N.getString("ImageWriteDescriptor25"));
-                            return false;
-                        }
-                    }
-                }
-            }
-        }
-
-        return true;
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/package.html zzx2/src/share/classes/com/sun/media/jai/operator/package.html
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/package.html	2005-02-11 00:01:57.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/operator/package.html	1969-12-31 19:00:00.000000000 -0500
@@ -1,52 +0,0 @@
-<!--
-$RCSfile: package.html,v $
-
-
-Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met: 
-
-- Redistribution of source code must retain the above copyright 
-  notice, this  list of conditions and the following disclaimer.
-
-- Redistribution in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer in 
-  the documentation and/or other materials provided with the
-  distribution.
-
-Neither the name of Sun Microsystems, Inc. or the names of 
-contributors may be used to endorse or promote products derived 
-from this software without specific prior written permission.
-
-This software is provided "AS IS," without a warranty of any 
-kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
-WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
-FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
-EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
-NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
-USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
-DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
-ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
-CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
-REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
-INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES. 
-
-You acknowledge that this software is not designed or intended for 
-use in the design, construction, operation or maintenance of any 
-nuclear facility. 
-
-$Revision: 1.1 $
-$Date: 2005/02/11 05:01:57 $
-$State: Exp $
--->
-<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
-<body>
-Provides JAI operations which read and write images using the Java Image
-I/O Framework. These operations are plug-ins which are automatically loaded
-using the <code>javax.media.jai.OperationRegistrySpi</code> mechanism of JAI.
-
-@since 1.0
-</body>
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/PrintProps.java zzx2/src/share/classes/com/sun/media/jai/operator/PrintProps.java
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/PrintProps.java	2005-02-11 00:01:57.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/operator/PrintProps.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,85 +0,0 @@
-/*
- * $RCSfile: PrintProps.java,v $
- *
- * 
- * Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met: 
- * 
- * - Redistribution of source code must retain the above copyright 
- *   notice, this  list of conditions and the following disclaimer.
- * 
- * - Redistribution in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in 
- *   the documentation and/or other materials provided with the
- *   distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of 
- * contributors may be used to endorse or promote products derived 
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any 
- * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
- * EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
- * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
- * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
- * DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
- * ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
- * CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
- * REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
- * INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES. 
- * 
- * You acknowledge that this software is not designed or intended for 
- * use in the design, construction, operation or maintenance of any 
- * nuclear facility. 
- *
- * $Revision: 1.1 $
- * $Date: 2005/02/11 05:01:57 $
- * $State: Exp $
- */
-package com.sun.media.jai.operator;
-
-import java.util.Collection;
-import java.util.Iterator;
-import javax.media.jai.PropertySource;
-
-final class PrintProps {
-    static final void print(PropertySource ps) {
-        String[] propNames = ps.getPropertyNames();
-        if(propNames != null) {
-            System.out.println("\nPROPERTIES OF "+
-                               ps.getClass().getName()+"@"+
-                               ps.hashCode()+":\n");
-            for(int j = 0; j < propNames.length; j++) {
-                Object propVal = ps.getProperty(propNames[j]);
-                if(propVal == null) {
-                    System.out.println(propNames[j]+" is NULL.");
-                } else if(propVal == java.awt.Image.UndefinedProperty) {
-                    System.out.println(propNames[j]+" is UNDEFINED.");
-                } else {
-                    System.out.println(propNames[j]+" = "+
-                                       propVal.getClass().getName()+"@"+
-                                       propVal.hashCode());
-                }
-            }
-        } else {
-            System.out.println("\n"+ps+" has no properties.");
-        }
-        System.out.println("\n");
-
-        if(ps instanceof Collection) {
-            Iterator iter = ((Collection)ps).iterator();
-            while(iter.hasNext()) {
-                Object nextElement = iter.next();
-                if(nextElement instanceof PropertySource) {
-                    print((PropertySource)nextElement);
-                }
-            }
-        }
-    }
-}
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/properties zzx2/src/share/classes/com/sun/media/jai/operator/properties
--- jai-imageio-core-cvs20091111-CLEANED/src/share/classes/com/sun/media/jai/operator/properties	2005-02-11 00:01:57.000000000 -0500
+++ zzx2/src/share/classes/com/sun/media/jai/operator/properties	1969-12-31 19:00:00.000000000 -0500
@@ -1,60 +0,0 @@
-#
-# $RCSfile: properties,v $
-#
-# Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.
-#
-# Use is subject to license terms.
-#
-# $Revision: 1.1 $
-# $Date: 2005/02/11 05:01:57 $
-# $State: Exp $
-#
-# Internationalization file for com.sun.media.jai.operator
-
-DescriptorVersion=1.0
-
-ImageReadDescriptor0=Reads an image using the Java Image I/O Framework.
-ImageReadDescriptor1=The input source.
-ImageReadDescriptor2=The index or indices of the image(s) to read.
-ImageReadDescriptor3=Whether metadata should be read if available.
-ImageReadDescriptor4=Whether thumbnails should be read if available.
-ImageReadDescriptor5=Whether to verify the validity of the input source.
-ImageReadDescriptor6=EventListeners to be registered with the ImageReader.
-ImageReadDescriptor7=The Locale for the ImageReader to use.
-ImageReadDescriptor8=Java Image I/O read parameter instance.
-ImageReadDescriptor9=Java Image I/O reader instance.
-ImageReadDescriptor10=Image index parameter must be non-negative.
-ImageReadDescriptor11=does not exist.
-ImageReadDescriptor12=is not readable.
-ImageReadDescriptor13=has its read-half shut down.
-ImageReadDescriptor14=is closed.
-ImageReadDescriptor15=is not bound to an address.
-ImageReadDescriptor16=is not connected.
-
-ImageWriteDescriptor0=Writes an image using the Java Image I/O Framework.
-ImageWriteDescriptor1=The output destination.
-ImageWriteDescriptor2=The format name of the output.
-ImageWriteDescriptor3=Whether to use image metadata properties as fallbacks.
-ImageWriteDescriptor4=Whether to transcode metadata before writing.
-ImageWriteDescriptor5=Whether to verify the validity of the output destination.
-ImageWriteDescriptor6=Whether to allow pixel replacement in the output image.
-ImageWriteDescriptor7=The tile size of the output image.
-ImageWriteDescriptor8=Stream metadata to write to the output.
-ImageWriteDescriptor9=Image metadata to write to the output.
-ImageWriteDescriptor10=Thumbnails to write to the output.
-ImageWriteDescriptor11=EventListeners to be registered with the ImageWriter.
-ImageWriteDescriptor12=The Locale for the ImageWriter to use.
-ImageWriteDescriptor13=Java Image I/O write parameter instance.
-ImageWriteDescriptor14=Java Image I/O writer instance.
-ImageWriteDescriptor15=exists but is not writable.
-ImageWriteDescriptor16=does not exist and cannot be created.
-ImageWriteDescriptor17=encountered IOException during createNewFile:
-ImageWriteDescriptor18=access denied by security manager:
-ImageWriteDescriptor19=has its write-half shut down.
-ImageWriteDescriptor20=is closed.
-ImageWriteDescriptor21=is not bound to an address.
-ImageWriteDescriptor22=is not connected.
-ImageWriteDescriptor23=Non-positive tile dimension specified.
-ImageWriteDescriptor24=No RenderedImages in the source Collection.
-ImageWriteDescriptor25=There is more than one RenderedImage in the source \
-Collection and the supplied ImageWriter cannot write sequences.
diff -urN jai-imageio-core-cvs20091111-CLEANED/src/share/services/javax.imageio.spi.ImageReaderSpi zzx2/src/share/services/javax.imageio.spi.ImageReaderSpi
--- jai-imageio-core-cvs20091111-CLEANED/src/share/services/javax.media.jai.OperationRegistrySpi	2005-02-11 00:02:44.000000000 -0500
+++ zzx2/src/share/services/javax.media.jai.OperationRegistrySpi	1969-12-31 19:00:00.000000000 -0500
@@ -1,47 +0,0 @@
-#
-# $RCSfile: javax.media.jai.OperationRegistrySpi,v $
-#
-# 
-# Copyright (c) 2005 Sun Microsystems, Inc. All  Rights Reserved.
-# 
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met: 
-# 
-# - Redistribution of source code must retain the above copyright 
-#   notice, this  list of conditions and the following disclaimer.
-# 
-# - Redistribution in binary form must reproduce the above copyright
-#   notice, this list of conditions and the following disclaimer in 
-#   the documentation and/or other materials provided with the
-#   distribution.
-# 
-# Neither the name of Sun Microsystems, Inc. or the names of 
-# contributors may be used to endorse or promote products derived 
-# from this software without specific prior written permission.
-# 
-# This software is provided "AS IS," without a warranty of any 
-# kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND 
-# WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, 
-# FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
-# EXCLUDED. SUN MIDROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL 
-# NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF 
-# USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS
-# DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR 
-# ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
-# CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND
-# REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR
-# INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGES. 
-# 
-# You acknowledge that this software is not designed or intended for 
-# use in the design, construction, operation or maintenance of any 
-# nuclear facility. 
-#
-# $Revision: 1.1 $
-# $Date: 2005/02/11 05:02:44 $
-# $State: Exp $
-#
-# --- JAI-Image I/O operations registration ---
-#
-com.sun.media.jai.imageioimpl.ImageReadWriteSpi
